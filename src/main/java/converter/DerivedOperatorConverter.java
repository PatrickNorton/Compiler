package main.java.converter;

import main.java.parser.OpSpTypeNode;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.List;

public final class DerivedOperatorConverter implements BaseConverter {
    private final DerivedOperatorNode node;
    private final CompilerInfo info;

    public DerivedOperatorConverter(CompilerInfo info, DerivedOperatorNode node) {
        this.node = node;
        this.info = info;
    }

    @Override
    @NotNull
    public List<Byte> convert(int start) {
        switch (node.getOperator()) {
            case EQUALS:
                return convertEquals(start);
            case COMPARE:
                throw CompilerTodoError.of("$derive(\\<=>)", node);
            case HASH:
                return convertHash();
            case REPR:
                return convertRepr();
            default:
                throw CompilerInternalError.of("Attempted to convert invalid operator", node);
        }
    }

    /**
     * Adds code for derived equality tests.
     * <p>
     *     The code generated for this is roughly equivalent to the following:
     *     <code><pre>
     * public method equals(Type other) {
     *     # Repeat the following for each field...
     *     if self.field != other.field {
     *         return false
     *     }
     *     # end repeat
     *     return true
     * }
     *     </pre></code>
     * </p>
     *
     * @param start The bytecode index to begin at
     * @return The generated bytecode
     */
    private List<Byte> convertEquals(int start) {
        var type = info.getType("self").orElseThrow();
        assert type instanceof UserType;
        List<Byte> bytes = new ArrayList<>();
        bytes.add(Bytecode.LOAD_VALUE.value);
        bytes.addAll(Util.shortZeroBytes());  // self
        bytes.add(Bytecode.GET_TYPE.value);
        bytes.add(Bytecode.LOAD_VALUE.value);
        bytes.addAll(Util.shortToBytes((short) 1));  // other
        bytes.add(Bytecode.GET_TYPE.value);
        bytes.add(Bytecode.EQUAL.value);
        bytes.addAll(postJumpBytes(start + bytes.size()));
        for (var field : ((UserType<?>) type).getFields()) {
            bytes.add(Bytecode.LOAD_VALUE.value);
            bytes.addAll(Util.shortZeroBytes());  // self
            bytes.add(Bytecode.LOAD_DOT.value);
            bytes.addAll(Util.shortToBytes(info.constIndex(LangConstant.of(field))));
            bytes.add(Bytecode.LOAD_VALUE.value);
            bytes.addAll(Util.shortToBytes((short) 1));  // other
            bytes.add(Bytecode.LOAD_DOT.value);
            bytes.addAll(Util.shortToBytes(info.constIndex(LangConstant.of(field))));
            bytes.add(Bytecode.EQUAL.value);
            bytes.addAll(postJumpBytes(start + bytes.size()));
        }
        return bytes;
    }

    private List<Byte> postJumpBytes(int start) {
        List<Byte> bytes = new ArrayList<>(postJumpSize());
        bytes.add(Bytecode.JUMP_TRUE.value);
        int jump = bytes.size();
        bytes.addAll(Util.zeroToBytes());
        bytes.add(Bytecode.LOAD_CONST.value);
        bytes.addAll(Util.shortToBytes(info.constIndex(Builtins.FALSE)));
        bytes.add(Bytecode.RETURN.value);
        bytes.addAll(Util.shortToBytes((short) 1));
        Util.emplace(bytes, Util.intToBytes(start + bytes.size()), jump);
        return bytes;
    }

    private int postJumpSize() {
        return Bytecode.JUMP_TRUE.size() + Bytecode.LOAD_CONST.size() + Bytecode.RETURN.size();
    }

    /**
     * Adds code for derived hash values.
     * <p>
     *     This code generates a tuple with each of the fields as a value and
     *     then calls the hash function on it.
     * </p>
     *
     * @return The generated bytecode
     */
    private List<Byte> convertHash() {
        var type = info.getType("self").orElseThrow();
        assert type instanceof UserType;
        List<Byte> bytes = new ArrayList<>();
        int fieldCount = 0;
        for (var field : ((UserType<?>) type).getFields()) {
            var fieldType = type.attrType(field, AccessLevel.PRIVATE).orElseThrow();
            if (fieldType.operatorInfo(OpSpTypeNode.HASH, AccessLevel.PRIVATE).isEmpty()) {
                throw CompilerException.format(
                        "Cannot derive hash for type '%s': " +
                                "Field %s has type '%s', which does not implement a hash operator",
                        node, type.name(), field, fieldType
                );
            }
            bytes.add(Bytecode.LOAD_VALUE.value);
            bytes.addAll(Util.shortZeroBytes());
            bytes.add(Bytecode.LOAD_DOT.value);
            bytes.addAll(Util.shortToBytes(info.constIndex(LangConstant.of(field))));
            fieldCount++;
        }
        bytes.add(Bytecode.PACK_TUPLE.value);
        bytes.addAll(Util.shortToBytes((short) fieldCount));
        bytes.add(Bytecode.CALL_OP.value);
        bytes.addAll(Util.shortToBytes((short) OpSpTypeNode.HASH.ordinal()));
        bytes.addAll(Util.shortZeroBytes());
        bytes.add(Bytecode.RETURN.value);
        bytes.addAll(Util.shortToBytes((short) 1));
        return bytes;
    }

    /**
     * Adds code for derived repr values.
     * <p>
     *     This code generates the following repr:
     *     <code><pre>
     * [Type name]{[field]=[repr(value)], ...} (for each field)
     *     </pre></code>
     * </p>
     * @return The bytecode to generate the representation
     */
    private List<Byte> convertRepr() {
        var type = info.getType("self").orElseThrow();
        assert type instanceof UserType;
        List<Byte> bytes = new ArrayList<>();
        if (((UserType<?>) type).isFinal() && ((UserType<?>) type).getGenericInfo().isEmpty()) {
            bytes.add(Bytecode.LOAD_CONST.value);
            bytes.addAll(Util.shortToBytes(info.constIndex(LangConstant.of(type.baseName() + '{'))));
        } else {
            bytes.add(Bytecode.LOAD_VALUE.value);
            bytes.addAll(Util.shortZeroBytes());
            bytes.add(Bytecode.GET_TYPE.value);
            bytes.add(Bytecode.CALL_OP.value);
            bytes.addAll(Util.shortToBytes((short) OpSpTypeNode.STR.ordinal()));
            bytes.addAll(Util.shortZeroBytes());
        }
        var first = true;
        for (var field : ((UserType<?>) type).getFields()) {
            var fieldName = first ? field + " = " : ", " + field + " = ";
            first = false;
            bytes.add(Bytecode.LOAD_CONST.value);
            bytes.addAll(Util.shortToBytes(info.constIndex(LangConstant.of(fieldName))));
            bytes.add(Bytecode.PLUS.value);
            bytes.add(Bytecode.LOAD_VALUE.value);
            bytes.addAll(Util.shortZeroBytes());
            bytes.add(Bytecode.LOAD_DOT.value);
            bytes.addAll(Util.shortToBytes(info.constIndex(LangConstant.of(field))));
            bytes.add(Bytecode.CALL_OP.value);
            bytes.addAll(Util.shortToBytes((short) OpSpTypeNode.REPR.ordinal()));
            bytes.addAll(Util.shortZeroBytes());
            bytes.add(Bytecode.PLUS.value);
        }
        bytes.add(Bytecode.LOAD_CONST.value);
        bytes.addAll(Util.shortToBytes(info.constIndex(LangConstant.of("}"))));
        bytes.add(Bytecode.PLUS.value);
        bytes.add(Bytecode.RETURN.value);
        bytes.addAll(Util.shortToBytes((short) 1));
        return bytes;
    }
}
