package main.java.converter;

import main.java.parser.OpSpTypeNode;
import main.java.util.Pair;
import org.jetbrains.annotations.NotNull;

public final class DerivedOperatorConverter implements BaseConverter {
    private final DerivedOperatorNode node;
    private final CompilerInfo info;

    public DerivedOperatorConverter(CompilerInfo info, DerivedOperatorNode node) {
        this.node = node;
        this.info = info;
    }

    @Override
    @NotNull
    public BytecodeList convert() {
        switch (node.getOperator()) {
            case EQUALS:
                return convertEquals();
            case COMPARE:
                return convertCompare();
            case HASH:
                return convertHash();
            case REPR:
                return convertRepr();
            default:
                throw CompilerInternalError.of("Attempted to convert invalid operator", node);
        }
    }

    @Override
    @NotNull
    public Pair<BytecodeList, DivergingInfo> convertAndReturn() {
        var divergingInfo = new DivergingInfo();
        divergingInfo.knownReturn();
        return Pair.of(convert(), divergingInfo);
    }

    /**
     * Adds code for derived equality tests.
     * <p>
     *     The code generated for this is roughly equivalent to the following:
     *     <code><pre>
     * public method equals(Type other) {
     *     # Repeat the following for each field...
     *     if self.field != other.field {
     *         return false
     *     }
     *     # end repeat
     *     return true
     * }
     *     </pre></code>
     * </p>
     *
     * @return The generated bytecode
     */
    @NotNull
    private BytecodeList convertEquals() {
        var type = info.getType("self").orElseThrow();
        assert type instanceof UserType;
        var bytes = new BytecodeList();
        bytes.add(Bytecode.LOAD_VALUE, 0);  // self
        bytes.add(Bytecode.GET_TYPE);
        bytes.add(Bytecode.LOAD_VALUE, 2);  // other
        bytes.add(Bytecode.GET_TYPE);
        bytes.add(Bytecode.EQUAL);
        bytes.addAll(postJumpBytes());
        for (var field : ((UserType<?>) type).getFields()) {
            bytes.add(Bytecode.LOAD_VALUE, 0);  // self
            bytes.add(Bytecode.LOAD_DOT, info.constIndex(LangConstant.of(field)));
            bytes.add(Bytecode.LOAD_VALUE, 2);
            bytes.add(Bytecode.LOAD_DOT, info.constIndex(LangConstant.of(field)));
            bytes.add(Bytecode.EQUAL);
            bytes.addAll(postJumpBytes());
        }
        bytes.add(Bytecode.LOAD_CONST, info.constIndex(Builtins.TRUE));
        bytes.add(Bytecode.RETURN, 1);
        return bytes;
    }

    @NotNull
    private BytecodeList postJumpBytes() {
        var bytes = new BytecodeList(4);
        var label = info.newJumpLabel();
        bytes.add(Bytecode.JUMP_TRUE, label);
        bytes.add(Bytecode.LOAD_CONST, info.constIndex(Builtins.FALSE));
        bytes.add(Bytecode.RETURN, 1);
        bytes.addLabel(label);
        return bytes;
    }

    @NotNull
    private BytecodeList convertCompare() {
        // FIXME: Get consistent return type for operator <=> (this uses int)
        var type = info.getType("self").orElseThrow();
        assert type instanceof UserType;
        var bytes = new BytecodeList();
        for (var field : ((UserType<?>) type).getFields()) {
            var fieldType = type.attrType(field, AccessLevel.PRIVATE).orElseThrow();
            if (fieldType.operatorInfo(OpSpTypeNode.COMPARE, AccessLevel.PRIVATE).isEmpty()) {
                throw CompilerException.format(
                        "Cannot derive <=> for type '%s': " +
                                "Field %s has type '%s', which does not implement a <=> operator",
                        node, type.name(), field, fieldType
                );
            }
            bytes.add(Bytecode.LOAD_VALUE, 0);  // self
            bytes.add(Bytecode.LOAD_DOT, info.constIndex(LangConstant.of(field)));
            bytes.add(Bytecode.LOAD_VALUE, 2);  // other
            bytes.add(Bytecode.LOAD_DOT, info.constIndex(LangConstant.of(field)));
            bytes.add(Bytecode.COMPARE);
            bytes.add(Bytecode.DUP_TOP);
            bytes.add(Bytecode.LOAD_CONST, info.constIndex(LangConstant.of(0)));
            bytes.add(Bytecode.EQUAL);
            var jumpLabel = info.newJumpLabel();
            bytes.add(Bytecode.JUMP_TRUE, jumpLabel);
            bytes.add(Bytecode.RETURN, 1);
            bytes.addLabel(jumpLabel);
        }
        bytes.add(Bytecode.LOAD_CONST, info.constIndex(LangConstant.of(0)));
        bytes.add(Bytecode.RETURN, 1);
        return bytes;
    }

    /**
     * Adds code for derived hash values.
     * <p>
     *     This code generates a tuple with each of the fields as a value and
     *     then calls the hash function on it.
     * </p>
     *
     * @return The generated bytecode
     */
    @NotNull
    private BytecodeList convertHash() {
        var type = info.getType("self").orElseThrow();
        assert type instanceof UserType;
        var bytes = new BytecodeList();
        int fieldCount = 0;
        for (var field : ((UserType<?>) type).getFields()) {
            var fieldType = type.attrType(field, AccessLevel.PRIVATE).orElseThrow();
            if (fieldType.operatorInfo(OpSpTypeNode.HASH, AccessLevel.PRIVATE).isEmpty()) {
                throw CompilerException.format(
                        "Cannot derive hash for type '%s': " +
                                "Field %s has type '%s', which does not implement a hash operator",
                        node, type.name(), field, fieldType
                );
            }
            bytes.add(Bytecode.LOAD_VALUE, 0);
            bytes.add(Bytecode.LOAD_DOT, info.constIndex(LangConstant.of(field)));
            fieldCount++;
        }
        bytes.add(Bytecode.PACK_TUPLE, fieldCount);
        bytes.addCallOp(OpSpTypeNode.HASH);
        bytes.add(Bytecode.RETURN, 1);
        return bytes;
    }

    /**
     * Adds code for derived repr values.
     * <p>
     *     This code generates the following repr:
     *     <code><pre>
     * [Type name]{[field]=[repr(value)], ...} (for each field)
     *     </pre></code>
     * </p>
     * @return The bytecode to generate the representation
     */
    @NotNull
    private BytecodeList convertRepr() {
        var type = info.getType("self").orElseThrow();
        assert type instanceof UserType;
        var bytes = new BytecodeList();
        if (((UserType<?>) type).isFinal() && ((UserType<?>) type).getGenericInfo().isEmpty()) {
            bytes.add(Bytecode.LOAD_CONST, info.constIndex(LangConstant.of(type.baseName() + '{')));
        } else {
            bytes.add(Bytecode.LOAD_VALUE, 0);
            bytes.add(Bytecode.GET_TYPE);
            bytes.addCallOp(OpSpTypeNode.STR);
        }
        var first = true;
        for (var field : ((UserType<?>) type).getFields()) {
            var fieldName = first ? field + " = " : ", " + field + " = ";
            first = false;
            bytes.add(Bytecode.LOAD_CONST, info.constIndex(LangConstant.of(fieldName)));
            bytes.add(Bytecode.PLUS);
            bytes.add(Bytecode.LOAD_VALUE, 0);
            bytes.add(Bytecode.LOAD_DOT, info.constIndex(LangConstant.of(field)));
            bytes.addCallOp(OpSpTypeNode.REPR);
            bytes.add(Bytecode.PLUS);
        }
        bytes.add(Bytecode.LOAD_CONST, info.constIndex(LangConstant.of("}")));
        bytes.add(Bytecode.PLUS);
        bytes.add(Bytecode.RETURN, 1);
        return bytes;
    }
}
