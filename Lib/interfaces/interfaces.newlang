export Boolable, Callable, Comparable, singleComparable, triComparable, Hashable, Iterable, Indexable, Sliceable

auto interface Boolable {
    operator bool
}

# auto interface Callable[*P, R] {
#     operator () (*P values, /) -> R
# }

auto interface Comparable[T] {
    operator <=> (T other, /)
    operator < (T other, /)
    operator > (T other, /)
    operator == (T other, /)

    operator <= (T other, /) {
        return self == other or self < other
    }
    operator >= (T other, /) {
        return self == other or self > other
    }
}

auto interface singleComparable[T] from Comparable[T] {
    operator <=> (T other, /)

    operator < (T other, /) {
        return (self <=> other) == -1
    }

    operator == (T other, /) {
        return (self <=> other) == 0
    }

    operator > (T other, /) {
        return (self <=> other) == 1
    }
}

auto interface triComparable from Comparable[T] {
    operator < (T other, /)
    operator > (T other, /)
    operator == (T other, /)

    operator <=> (T other, /) {
        return 0 if self == other
        return 1 if self > other
        return -1
    }
}

auto interface Hashable {
    operator hash
}

# auto interface Iterable[T] {
#     pubget int length
#
#     operator iter -> T
#
#     operator in (T value, /) {
#         for T i in self {
#             return true if value == i
#         }
#         return false
#     }
# }

auto interface Indexable[K, V] {
    operator [] (K key, /) -> V
    operator []= (K key, V value, /)
}

auto interface Sliceable[V] {
    operator [:] (int start, int stop, int step, /) -> Iterable[V]
    operator [:]= (int start, int stop, int step, Iterable[V] values, /)
}
