from .literal import LiteralSearcher
from .prog import InstEmptyLook

export InputAt, Input, CharInput, ByteInput

class InputAt {
    pubget mut int pos
    char? c
    int? byte_
    pubget mut int length

    public operator bool {
        return bool(self.length)
    }

    public method isStart() -> bool {
        return self.pos == 0
    }

    public method isEnd() -> bool {
        return not self.c? and not self.byte_?
    }

    public method chr() -> char? {
        return self.c
    }

    public method byte() -> int? {
        return self.byte_
    }

    public method nextPos() -> int {
        return self.pos + self.length
    }
}

interface Input {
    public method at(int i) -> InputAt

    public method nextChar(InputAt at) -> char?

    public method previousChar(InputAt at) -> char?

    public method isEmptyMatch(InputAt at, InstEmptyLook empty) -> bool

    public method prefixAt(LiteralSearcher prefixes, InputAt at) -> InputAt?

    public int length

    public operator bool {
        return bool(self.length)
    }

    public method asBytes() -> bytes
}

class CharInput from Input {
    public bytes value

    public operator new(bytes value) {
        self.value = value
    }

    public operator [] (int i) -> int {
        return self.value[i]
    }

    public operator [:] (slice s) -> bytes {
        return self.value.operator[:](s)
    }

    public method at(int i) -> InputAt {
        if i >= self.length {
            return InputAt(self.length, Char(null), null, 0)
        } else {
            var c = str(self[i:])[0]
            return InputAt(self.length, Char(c), null, bytes(c).length)
        }
    }

    public method nextChar(InputAt at) -> char? {
        return at.chr()
    }

    public method previousChar(InputAt at) -> char? {
        return Char(str(self[:at.pos])[-1])
    }

    public method isEmptyMatch(InputAt at, InstEmptyLook empty) -> bool {
        switch empty.look {
            case EmptyLook.StartLine {
                var c = self.previousChar(at)
                return not at.pos or c == "\n"[0]
            }
            case EmptyLook.EndLine {
                var c = self.nextChar(at)
                return at.pos == self.length or c == "\n"[0]
            }
            case EmptyLook.StartText {
                return at.pos == 0
            }
            case EmptyLook.EndText {
                return at.pos == self.length
            }
            case EmptyLook.WordBoundary {
                var c1, var c2 = self.previousChar(at), self.nextChar(at)
                return c1.isWordChar() ^ c2.isWordChar()
            }
            case EmptyLook.NotWordBoundary {
                var c1, var c2 = self.previousChar(at), self.nextChar(at)
                return not c1.isWordChar() ^ c2.isWordChar()
            }
            case EmptyLook.WordBoundaryAscii {
                var c1, var c2 = self.previousChar(at), self.nextChar(at)
                return c1.isWordByte() ^ c2.isWordByte()
            }
            case EmptyLook.NotWordBoundaryAscii {
                var c1, var c2 = self.previousChar(at), self.nextChar(at)
                return not c1.isWordByte() ^ c2.isWordByte()
            }
        }
    }

    public method prefixAt(LiteralSearcher prefixes, InputAt at) -> InputAt? {
        var s = prefixes.find(self[at.pos:]).first
        return self.at(at.pos + s)
    }

    public property int length {
        get {
            return self.value.length
        }
    }

    public method asBytes() -> bytes {
        return self.value
    }
}

class ByteInput from Input {
    bytes text
    bool onlyUtf8

    public operator new(bytes text, bool onlyUtf8) {
        self.text = text
        self.onlyUtf8 = onlyUtf8
    }

    public operator [] (int i) -> int {
        return self.text[i]
    }

    public operator [:] (slice s) -> bytes {
        return self.text.operator[:](s)
    }

    public method at(int i) -> InputAt {
        if i >= self.len() {
            return InputAt(self.length, null, null, 0)
        } else {
            return InputAt(i, null, self[i], 1)
        }
    }

    public method nextChar(InputAt at) -> char? {
        return decodeUtf8(self[at.pos:])?.0
    }

    public method previousChar(InputAt at) -> char? {
        return decodeLastUtf8(self[:at.pos])?.0
    }

    public method isEmptyMatch(InputAt at, InstEmptyLook empty) -> bool {
        switch empty.look {
            case EmptyLook.StartLine {
                var c = self.previousChar(at)
                return not at.pos or c == '\n'[0]
            }
            case EmptyLook.EndLine {
                var c = self.nextChar(at)
                return at.pos == self.length or c == '\n'
            }
            case EmptyLook.StartText {
                return at.pos() == 0
            }
            case EmptyLook.EndText {
                return at.pos() == self.len()
            }
            case EmptyLook.WordBoundary {
                var c1, var c2 = self.previousChar(at), self.nextChar(at)
                return c1.isWordChar() != c2.isWordChar()
            }
            case EmptyLook.NotWordBoundary {
                var c1, var c2 = self.previousChar(at), self.nextChar(at)
                return c1.isWordChar() == c2.isWordChar()
            }
            case EmptyLook.WordBoundaryAscii {
                var c1, var c2 = self.previousChar(at), self.nextChar(at)
                if self.onlyUtf8 {
                    # If we must match UTF-8, then we can't match word
                    # boundaries at invalid UTF-8.
                    return false if not c1? and not at.isStart()
                    return false if c2? and not at.isEnd()
                }
                return c1.isWordByte() != c2.isWordByte()
            }
            case EmptyLook.NotWordBoundaryAscii {
                var c1, var c2 = self.previousChar(at), self.nextChar(at)
                if self.only_utf8 {
                    # If we must match UTF-8, then we can't match word
                    # boundaries at invalid UTF-8.
                    return false if not c1? and not at.isStart()
                    return false if c2? and not at.isEnd()
                }
                return c1.isWordByte() == c2.isWordByte()
            }
        }
    }

    public method prefixAt(
        LiteralSearcher prefixes,
        InputAt at,
    ) -> InputAt? {
        return prefixes.find(self[at.pos:]).map(lambda s => self.at(at.pos + s.0))
    }

    public property int length {
        get {
            return self.text.length
        }
    }

    public method asBytes() -> bytes {
        return self.text
    }
}
