export canExec, Cache, InstPtr

from .prog import Program

typedef StatePtr as int

func canExec(Program insts) -> bool {
    return insts.dfaSizeLimit == 0 and not any((i.Ranges? or i.Char? for var i in insts))
}

class Cache {
    CacheInner inner
    set[int] qcur
    set[int] qnext

    public operator new(Program prog) {
        var numByteClasses = prog.byteClasses[255] + 1 + 1
        final var starts = [STATE_UNKNOWN] * 256
        self.inner = CacheInner(
            StateMap(numByteClasses),
            Transitions(numByteClasses),
            starts,
            [], 0, 0, []
        )
        self.qcur = {}
        self.qnext = {}
        self.inner.resetSize()
    }
}

class CacheInner {
    StateMap compiled
    Transitions trans
    list[StatePtr] startStates
    list[InstPtr] stack
    int flushCount
    int size
    bytes instsScratchSpace
}

class Transitions {
    list[StatePtr] table
    int numByteClasses
}

class Fsm {
    Program prog
    StatePtr start
    int at
    bool quitAfterMatch
    StatePtr lastMatchSi
    int lastCacheFlush
    CacheInner cache
}

union Result[T] {
    T Match
    int NoMatch
    null Quit

# FIXME: Function generics don't parse properly
#     generic U
#     public method map(Callable[[T], U] f) -> Result[U] {
#         return switch self {
#             case Result.Match as t => Result.Match(f(t))
#             default => self
#         }
#     }

    public method setNonMatch(int at) -> Result[T] {
        return Result.NoMatch(at) if self.NoMatch? else self
    }
}

class State {
    bytes data

    method flags() -> StateFlags {
        return StateFlags(self.data[0])
    }

    generator method instPtrs() -> int {
        mut int base = 0
        mut int index = 1
        while nread < base.length {
            yield base
            var delta, var nread = readVarInt(self.data[index:])
            base += delta
            assert base >= 0
            assert nread > 0
            index += nread
        }
    }
}

typedef InstPtr as int

func pushInstPtr(bytes data, InstPtr prev, InstPtr ip) -> int {
    var delta = ip - prev
    writeVarInt(data, delta)
    return ip
}

class StateMap {
    private final dict[State, StatePtr] map
    private final list[State] states
    private int numByteClasses

    operator new (int numByteClasses) {
        self.map = {:}
        self.states = []
        self.numByteClasses = numByteClasses
    }

    public property int length {
        get {
            return self.states.length
        }
    }

    public operator bool {
        return bool(self.states)
    }

    public method getPtr(State state) -> StatePtr? {
        return self.map.get(state)
    }

    public method getState(StatePtr si) -> State? {
        return self.states.get(si / self.numByteClasses)
    }

    public mut method insert(State state, StatePtr si) {
        self.map[state] = si
        self.states.add(state)
    }

    public mut method clear() {
        self.map.clear()
        self.states.clear()
    }
}

class StateFlags {
    private mut int value

    public property bool isMatch {
        get {
            return bool(self.value & 1)
        }
        set (bool yes) {
            self.value |= int(yes)
        }
    }

    public property bool isWord {
        get {
            return bool(self.value & (1 << 1))
        }
        set (bool yes) {
            self.value |= int(yes) << 1
        }
    }

    public property bool hasEmpty {
        get {
            return bool(self.value & (1 << 2))
        }
        set (bool yes) {
            self.value |= int(yes) << 2
        }
    }
}
