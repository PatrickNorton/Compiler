from ..ast import Ast, visit, Visitor
from .hir import Hir, ClassUnicode, ClassBytes

export HirBuilder, Translator

class HirBuilder {
    mut bool allowInvalidUtf8_
    Flags flags

    public operator new {
        self.allowInvalidUtf8_ = false
        self.flags = Flags()
    }

    public method build() -> mut Translator {
        list[HirFrame] empty = []  # FIXME
        return Translator(empty, self.flags, self.allowInvalidUtf8_)
    }

    public mut method allowInvalidUtf8(bool yes) {
        self.allowInvalidUtf8_ = yes
    }

    public method swapGreed(bool yes) {
        self.flags.swapGreed = yes
    }

    public method multiLine(bool yes) {
        self.flags.multiLine = yes
    }

    public method dotMatchesNewline(bool yes) {
        self.flags.dotMatchesNewline = yes
    }

    public method caseInsensitive(bool yes) {
        self.flags.caseInsensitive = yes
    }

    public method unicode(bool yes) {
        self.flags.unicode = yes
    }
}
#|

impl TranslatorBuilder {

    /// When enabled, translation will permit the construction of a regular
    /// expression that may match invalid UTF-8.
    ///
    /// When disabled (the default), the translator is guaranteed to produce
    /// an expression that will only ever match valid UTF-8 (otherwise, the
    /// translator will return an error).
    ///
    /// Perhaps surprisingly, when invalid UTF-8 isn't allowed, a negated ASCII
    /// word boundary (uttered as `(?-u:\B)` in the concrete syntax) will cause
    /// the parser to return an error. Namely, a negated ASCII word boundary
    /// can result in matching positions that aren't valid UTF-8 boundaries.
    pub fn allow_invalid_utf8(&mut self, yes: bool) -> &mut TranslatorBuilder {
        self.allow_invalid_utf8 = yes;
        self
    }

    /// Enable or disable the case insensitive flag (`i`) by default.
    pub fn case_insensitive(&mut self, yes: bool) -> &mut TranslatorBuilder {
        self.flags.case_insensitive = if yes { Some(true) } else { None };
        self
    }

    /// Enable or disable the multi-line matching flag (`m`) by default.
    pub fn multi_line(&mut self, yes: bool) -> &mut TranslatorBuilder {
        self.flags.multi_line = if yes { Some(true) } else { None };
        self
    }

    /// Enable or disable the "dot matches any character" flag (`s`) by
    /// default.
    pub fn dot_matches_new_line(
        &mut self,
        yes: bool,
    ) -> &mut TranslatorBuilder {
        self.flags.dot_matches_new_line = if yes { Some(true) } else { None };
        self
    }

    /// Enable or disable the "swap greed" flag (`U`) by default.
    pub fn swap_greed(&mut self, yes: bool) -> &mut TranslatorBuilder {
        self.flags.swap_greed = if yes { Some(true) } else { None };
        self
    }

    /// Enable or disable the Unicode flag (`u`) by default.
    pub fn unicode(&mut self, yes: bool) -> &mut TranslatorBuilder {
        self.flags.unicode = if yes { None } else { Some(false) };
        self
    }
}
|#

class Flags {
    bool? caseInsensitive
    bool? multiLine
    bool? dotMatchesNewline
    bool? swapGreed
    bool? unicode

    public operator new() {
        self.caseInsensitive = null
        self.multiLine = null
        self.dotMatchesNewline = null
        self.swapGreed = null
        self.unicode = null
    }
}

class Translator {
    final list[HirFrame] stack
    final Flags flags
    bool allowInvalidUtf8

    operator new(mut list[HirFrame] stack, mut Flags flags, bool allowInvalidUtf8) {
        self.stack = stack
        self.flags = flags
        self.allowInvalidUtf8 = allowInvalidUtf8
    }

    public method translate(str pattern, Ast ast) -> Hir {
        return visit(ast, TranslatorI(self, pattern))
    }
}

class TranslatorI from Visitor[Hir] {
    final Translator trans
    str pattern

    public operator new(mut Translator trans, str pattern) {
        self.trans = trans
        self.pattern = pattern
    }

    mut method pop() -> HirFrame? {
        return self.trans.stack.pop()
    }

    public mut method finish() -> Hir {
        assert self.trans.stack.length == 1 as f"Stack length should be 1, instead {self.trans.stack.length}"
        return self.pop()!!.unwrapExpr()
    }
}

union HirFrame {
    Hir Expr
    ClassUnicode ClassUnicode
    ClassBytes ClassBytes
    Flags Group
    null Concat
    null Alternation

    method unwrapExpr() -> Hir {
        if self.Expr? as expr {
            return expr
        } else {
            raise ValueError(f"Tried to unwrap expr from HirFrame, got: {self !r}")
        }
    }
}
