from itertools import all

export Utf8Sequence, Utf8Range, Utf8Sequences, nextUtf8

int MAX_UTF8_BYTES = 4

func nextUtf8(bytes text, int i) -> int {
    return i + 1 if not text.get(i)?
    var b = text[i]
    if b <= 0x7F {
        return i + 1
    } elif b <= 0b110_11111 {
        return i + 2
    } elif b <= 0b1110_1111 {
        return i + 3
    } else {
        return i + 4
    }
}

const union Utf8Sequence {
    Utf8Range One
    tuple[Utf8Range, Utf8Range] Two
    tuple[Utf8Range, Utf8Range, Utf8Range] Three
    tuple[Utf8Range, Utf8Range, Utf8Range, Utf8Range] Four

    public property int length {
        get {
            return switch self {
                case Utf8Sequence.One => 1
                case Utf8Sequence.Two => 2
                case Utf8Sequence.Three => 3
                case Utf8Sequence.Four => 4
            }
        }
    }

    static method fromEncodedRange(bytes start, bytes end) -> cls {
        assert start.length == end.length
        return switch start.length {
            case 2 => Utf8Sequence.Two(
                (
                    Utf8Range(start[0], end[0]),
                    Utf8Range(start[1], end[1]),
                )
            )
            case 3 => Utf8Sequence.Three(
                (
                    Utf8Range(start[0], end[0]),
                    Utf8Range(start[1], end[1]),
                    Utf8Range(start[2], end[2]),
                )
            )
            case 4 => Utf8Sequence.Four(
                (
                    Utf8Range(start[0], end[0]),
                    Utf8Range(start[1], end[1]),
                    Utf8Range(start[2], end[2]),
                    Utf8Range(start[3], end[3])
                )
            )
            default => raise NotImplemented() # raise ValueError(f"invalid encoded length: {n}")
        }
    }

    public operator iter -> Utf8Range {
        switch self {
            case Utf8Sequence.One as r {
                yield r
            }
            case Utf8Sequence.Two as r {
                yield r.0
                yield r.1
            }
            case Utf8Sequence.Three as r {
                yield r.0
                yield r.1
                yield r.2
            }
            case Utf8Sequence.Four as r {
                yield r.0
                yield r.1
                yield r.2
                yield r.3
            }
        }
    }

    public operator reversed -> Utf8Range {
        switch self {
            case Utf8Sequence.One as r {
                yield r
            }
            case Utf8Sequence.Two as r {
                yield r.1
                yield r.0
            }
            case Utf8Sequence.Three as r {
                yield r.2
                yield r.1
                yield r.0
            }
            case Utf8Sequence.Four as r {
                yield r.3
                yield r.2
                yield r.1
                yield r.0
            }
        }
    }

    public method matches(bytes val) -> bool {
        return false if val.length < self.length

        for var b, var r in val, self {  # FIXME: Use all() & a generator
            return false if not r.matches(b)
        }
        return true
    }
}

const class Utf8Range {
    public int start
    public int end

    public operator new(int start, int end) {
        assert start in [0:256] and end in [0:256]
        self.start = start
        self.end = end
    }

    public method matches(int b) -> bool {
        return b in [self.start:self.end]
    }
}

class Utf8Sequences {
    final list[ScalarRange] rangeStack

    public operator new(char start, char end) {
        self.rangeStack = [ScalarRange(int(start), int(end))]
    }

    public operator iter -> Utf8Sequence {
        final var ranges = self.rangeStack[:]
        while ranges.pop()? as r {
            if self.iterInner(r, ranges)? as seq {
                yield seq
            }
        }
    }

    private method iterInner(ScalarRange scalar, mut list[ScalarRange] rangeStack) -> Utf8Sequence? {
        mref var r = scalar
        while true {
            if r.split()? as pair {
                rangeStack.add(pair.1)
                r = pair.0
                continue
            }
            continue if not r.isValid()
            for var i in [1:MAX_UTF8_BYTES] {
                var max = maxScalarValue(i)
                if max in r {
                    rangeStack.add(ScalarRange(max + 1, r.end))
                    r = ScalarRange(r.start, max)
                    break
                }
            } nobreak {
                if r.asAscii()? as asciiRange {
                    return Utf8Sequence.One(asciiRange)
                }
                for i in [1:MAX_UTF8_BYTES] {
                    var m = (1 << (6 * i)) - 1
                    if (r.start & ~m) != (r.end & ~m) {
                        if (r.start & m) != 0 {
                            rangeStack.add(ScalarRange((r.start | m) + 1, r.end))
                            r = ScalarRange(r.start, r.start | m)
                            break
                        }
                        if (r.end & m) != m {
                            rangeStack.add(ScalarRange(r.end & ~m, r.end))
                            r = ScalarRange(r.start, (r.end & ~m) - 1)
                            break
                        }
                    }
                } nobreak {
                    var start, var end = r.encode()
                    return Utf8Sequence.fromEncodedRange(start, end)
                }
            }
        }
    }

    public mut method reset(char start, char end) {
        self.rangeStack.clear()
        self.rangeStack.add(ScalarRange(int(start), int(end)))
    }
}

class ScalarRange {
    int start
    int end

    public operator new(int start, int end) {
        self.start = start
        self.end = end
    }

    public operator in (int value) {
        return value in [self.start:self.end]
    }

    method split() -> tuple[cls, cls]? {
        if self.start < 0xE000 and self.end > 0xD7FF {
           var s1 = ScalarRange(self.start, 0xD7FF)
           var s2 = ScalarRange(0xE000, self.end)
           return (s1, s2)
        } else {
            return null
        }
    }

    method isValid() -> bool {
        return self.start <= self.end
    }

    method asAscii() -> Utf8Range? {
        if self.isAscii() {
            return Utf8Range(self.start, self.end)
        } else {
            return null
        }
    }

    method isAscii() -> bool {
        return self.isValid() and self.end <= 0x7f
    }

    method encode() -> bytes, bytes {
        return str(char(self.start)).encode("UTF-8"), str(char(self.end)).encode("UTF-8")
    }
}

func maxScalarValue(int byteCount) -> int {
    return switch byteCount {
        case 1 => 0x007F
        case 2 => 0x07FF
        case 3 => 0xFFFF
        case 4 => 0x10FFFF
        default => raise ValueError("invalid UTF-8 byte sequence size")
    }
}
