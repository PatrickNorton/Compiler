from .patterns import Patterns
from .teddy import Teddy
from .rabinkarp import RabinKarp

from ..match import Match

export Config, MatchKind, Builder, ForceAlgorithm, Searcher

var PATTERN_LIMIT = 128

enum MatchKind {
    LEFTMOST_FIRST,
    LEFTMOST_LONGEST
}

class Config {
    mut MatchKind kind
    mut ForceAlgorithm? force
    mut bool? forceTeddyFat_
    mut bool? forceAvx_

    public operator new() {
        self.kind = MatchKind.LEFTMOST_FIRST
        self.force = null
        self.forceTeddyFat = null
        self.forceAvx = null
    }

    public method builder() -> Builder {
        return Builder.fromConfig(self)
    }

    public mut method matchKind(MatchKind kind) -> cls {
        self.kind = kind
        return self
    }

    public mut method forceTeddy(bool yes) -> cls {
        self.force = ForceAlgorithm.TEDDY if yes else null
        return self
    }

    public mut method forceTeddyFat(bool yes) -> cls {
        self.forceTeddyFat_ = yes
        return self
    }

    public mut method forceAvx(bool yes) -> cls {
        self.forceAvx_ = yes
        return self
    }

    public mut method forceRabinKarp(bool yes) -> cls {
        self.force = ForceAlgorithm.RABIN_KARP if yes else null
        return self
    }

    public method clone() -> cls {
        return cls(self.kind, self.force, self.forceTeddyFat_, self.forceAvx_)
    }
}

enum ForceAlgorithm {
    TEDDY,
    RABIN_KARP
}

class Builder {
    Config config
    bool inert
    Patterns patterns

    public operator new(Config config = Config()) {
        self.config = config
        self.inert = false
        self.patterns = patterns
    }

    public method build() -> Searcher? {
        return null if self.inert or not self.patterns

        mut var patterns = self.patterns.clone()
        patterns.setMatchKind(self.config.kind)
        var rabinKarp = RabinKarp(patterns)
        SearchKind searchKind
        int minimumLen
        if self.config.force? as f {
            switch f {
                case ForceAlgorithm.TEDDY {
                    Teddy teddy
                    if self.buildTeddy(patterns)? as t {
                        teddy = t
                    } else {
                        return null
                    }
                    minimumLen = teddy.minimumLen()
                    searchKind = SearchKind.Teddy(teddy)
                }
                case ForceAlgorithm.RABIN_KARP {
                    minimumLen = 0
                    searchKind = SearchKind.RabinKarp()
                }
            }
        } else {
            Teddy teddy
            if self.buildTeddy(patterns)? as t {
                teddy = t
            } else {
                return null
            }
            minimumLen = teddy.minimumLen()
            searchKind = SearchKind.Teddy(teddy)
        }
        return Searcher(self.config.clone(), patterns, rabinKarp, searchKind, minimumLen)
    }

    public mut method add(bytes pattern) -> cls {
        return self if self.inert
        if self.patterns.length >= PATTERN_LIMIT {
            self.inert = true
            self.patterns.reset()
            return self
        }

        if not pattern {
            self.inert = true
            self.patterns.reset()
            return self
        }
        self.patterns.add(pattern)
        return self
    }

    public mut method extend(Iterable[bytes] patterns) -> cls {
        for var p in patterns {
            self.add(p)
        }
        return self
    }
}

union SearchKind {
    Teddy Teddy
    null RabinKarp
}

class Searcher {
    Config config
    Patterns patterns
    RabinKarp rabinKarp
    SearchKind searchKind
    int minimumLen

    public method find(bytes haystack) -> Match? {
        return self.findAt(haystack, 0)
    }

    public method findAt(bytes haystack, int at) -> Match? {
        switch self.searchKind {
            case SearchKind.Teddy as teddy {
                if haystack[at:].length < teddy.minimumLength {
                    return self.slowAt(haystack, at)
                }
                return teddy.findAt(self.patterns, haystack, at)
            }
            case SearchKind.RabinKarp {
                return self.rabinKarp.findAt(self.patterns, haystack, at)
            }
        }
    }

    public generator method findIter(bytes haystack) -> Match {
        var at = 0
        while at < haystack.length {
            if self.searcher.findAt(haystack, at)? as c {
                at = c.end
                yield c
            } else {
                return
            }
        }
    }

    private method slowAt(bytes haystack, int at) -> Match? {
        return self.rabinKarp.findAt(self.patterns, haystack, at)
    }
}
