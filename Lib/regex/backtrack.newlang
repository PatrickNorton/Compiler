from collections import Pair

export Bounded, Cache

var BIT_SIZE = 32
var MAX_SIZE_BYTES = 256 * (1 << 10) # 256 KB

func shouldExec(int numInsts, int textLen) -> bool {
    var size = ((num_insts * (text_len + 1) + BIT_SIZE - 1) / BIT_SIZE) * 4
    return size <= MAX_SIZE_BYTES
}

class Bounded {
    private Program prog
    private Input inputVal
    private list[bool] matches
    private list[Slot] slots
    private final Cache m

    private operator new(
        Program prog,
        Input inputVal,
        list[bool] matches,
        list[Slot] slots,
        Cache m,
    ) {
        self.prog = prog
        self.inputVal = inputVal
        self.matches = matches
        self.slots = slots
        self.m = m
    }

    public static method exec(
        Program prog,
        ProgramCache cache,
        list[bool] matches,
        list[Slot] slots,
        Input inputVal,
        int start,
        int end,
    ) -> bool {
        var trueCache = cache.backtrack
        var start = inputVal.at(start)
        final var b = Bounded(prog, inputVal, matches, slots, trueCache)
        return b.exec_(start, end)
    }

    private mut method clear() {
        self.m.jobs.clear()
        self.m.visited.clear()
    }

    private mut method exec_(mut InputAt at, int end) -> bool {
        self.clear()
        if self.prog.isAnchoredStart {
            return false if not at.isStart() else self.backtrack(at)
        }
        mut var matched = false
        while true {
            if self.prog.prefixes {
                if self.inputPrefixAt(self.prog.prefixes, at)? as a {
                    at = a
                } else {
                    break
                }
            }
            matched = self.backtrack(at) or matched
            if matched and self.prog.matches.length == 1 {
                return true
            }
            break if at.pos >= end
            at = self.inputVal.at(at.nextPos())
        }
        return matched
    }

    private mut method backtrack(InputAt start) -> bool {
        mut var matched = false
        self.m.jobs.add(Job.Inst(0, start))
        while jobs {
            switch jobs.pop() {
                case Job.Inst as pair {
                    if self.step(pair.first, pair.second) {
                        return true if self.prog.matches.length == 1
                        matches = true
                    }
                }
                case Job.SaveRestore as pair {
                    if pair.first < self.slots.length {
                        self.slots[pair.first] = pair.second
                    }
                }
            }
        }
        return matched
    }

    private mut method step(InstPtr ip_, InputAt at_) -> bool {
        mref var ip = ip_
        mref var at = at_
        while true {
            return false if self.hasVisited(ip, at)
            switch self.prog[ip] {
                case Inst.Match as slot {
                    if slot < self.matches.length {
                        self.matches[slot] = true
                    }
                    return true
                }
                case Inst.Save as inst {
                    if self.slots.get(inst.slot)? as oldSlot {
                        self.m.jobs.add(Job.SaveRestore(Pair(inst.slot, oldPos)))
                        self.slots[inst.slot] = at.pos
                    }
                    ip = inst.jump
                }
                case Inst.Split as inst {
                    self.m.jobs.push(Job.Inst(Pair(inst.goto2, at)))
                    ip = inst.goto1
                }
                case Inst.EmptyLook as inst {
                    if self.inputVal.isEmptyMatch(at, inst) {
                        ip = inst.jump
                    } else {
                        return false
                    }
                }
                case Inst.Char as inst {
                    if inst.c == at.chr() {
                        ip = inst.jump
                        at = self.inputVal.at(at.nextPos())
                    } else {
                        return false
                    }
                }
                case Inst.Ranges as inst {
                    if inst.matches(at.chr()) {
                        ip = inst.jump
                        at = self.inputVal.at(at.nextPos())
                    } else {
                        return false
                    }
                }
                case Inst.Bytes as inst {
                    if at.byte()? as b {
                        if inst.matches(b) {
                            ip = inst.jump
                            at = self.inputVal.at(at.nextPos())
                            continue
                        }
                    }
                    return false
                }
            }
        }
    }

    private mut method hasVisited(InstPtr ip, InputAt at) -> bool {
        var k = ip * (self.inputVal.length + 1) + at.pos()
        var k1 = k / BIT_SIZE
        var k2 = 1 << (k & BIT_SIZE - 1)
        if self.m.visited[k1] and not k2 {
            self.m.visited[k1] |= k2
            return false
        } else {
            return true
        }
    }
}

class Cache {
    final list[Job] jobs
    final list[Bits] visited

    public operator new(Program prog) {
        self.jobs = []
        self.visited = []
    }
}

union Job {
    Pair[InstPtr, InputAt] Inst
    Pair[int, int?] SaveRestore
}
