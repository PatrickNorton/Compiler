# Imports: LiteralSearcher

export Program, Inst, InstSave, InstSplit, InstEmptyLook
export InstChar, InstRanges, InstBytes, EmptyLook, InstPtr

typedef InstPtr as int

class Program {
    public list[Inst] insts
    public list[InstPtr] matches
    public list[str?] captures
    public dict[str, int] captureNameIdx
    public InstPtr start
    public bytes byteClasses
    public bool onlyUtf8
    public bool isBytes
    public bool isDfa
    public bool isReverse
    public bool isAnchoredStart
    public bool isAnchoredEnd
    public bool hasUnicodeWordBoundary
    public LiteralSearcher prefixes
    public int dfaSizeLimit

    public operator new() {
        self.insts = []
        self.matches = []
        self.captures = []
        self.captureNameIdx = {:}
        self.start = 0
        self.byte_classes = bytes()
        self.only_utf8 = true
        self.isBytes = false
        self.isDfa: false
        self.isReverse: false
        self.isAnchoredStart = false
        self.isAnchoredEnd = false
        self.has_unicode_word_boundary = false
        self.prefixes = LiteralSearcher()
        self.dfa_size_limit = 2 * (1 << 20)
    }

    public operator [] (int index) -> Inst {
        return self.insts[index]
    }

    public operator iter () -> Inst {
        yield from self.insts
    }

    public method skip(int pc) -> int {
        mut int pc2 = pc
        while true {
            switch self[pc2] {
                case Inst.Save as i {
                    pc2 = i.jump
                }
                default {
                    return pc2
                }
            }
        }
    }

    public method leadsToMatch(int pc) -> bool {
        if self.matches.length > 1 {
            # If we have a regex set, then we have more than one ending
            # state, so leading to one of those states is generally
            # meaningless.
            return false
        }
        return self[self.skip(pc)].Match?
    }

    public method needsDotstar() -> bool {
        return self.isDfa and not self.isReverse and not self.isAnchoredStart
    }

    public method usesBytes() -> bool {
        return self.isBytes or self.isDfa
    }
}

union Inst {
    int Match
    InstSave Save
    InstSplit Split
    InstEmptyLook EmptyLook
    InstChar Char
    InstRanges Ranges
    InstBytes Bytes

    public method isMatch() -> bool {
        return self.Match?
    }
}

class InstSave {
    public InstPtr jump
    public int slot
}

class InstSplit {
    public InstPtr jump1
    public InstPtr jump2
}

class InstEmptyLook {
    public InstPtr jump
    public EmptyLook look
}

enum EmptyLook {
    # Start of line or input.
    START_LINE,
    # End of line or input.
    END_LINE,
    # Start of input.
    START_TEXT,
    # End of input.
    END_TEXT,
    # Word character on one side and non-word character on other.
    WORD_BOUNDARY,
    # Word character on both sides or non-word character on both sides.
    NOT_WORD_BOUNDARY,
    # ASCII word boundary.
    WORD_BOUNDARY_ASCII,
    # Not ASCII word boundary.
    NOT_WORD_BOUNDARY_ASCII,
}

class InstChar {
    public InstPtr jump
    public char c
}

class InstRanges {
    public InstPtr jump
    public list[Pair[char, char]] ranges

    public method matches(char c) -> bool {
        for var r in self.ranges[:4] {
            return false if c < r.first
            return true if c <= r.second
        }
        return c in self.ranges
    }

    public method numChars() -> int {
        return sum((1 + x.first - x.second for var x in self.ranges))
    }
}

class InstBytes {
    public InstPtr jump
    public int start
    public int end

    public method matches(int b) -> bool {
        return b in [self.start:self.end+1]
    }
}
