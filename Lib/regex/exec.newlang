from .AhoCorasick import AhoCorasick
from .prog import Program
from .builder import RegexOptions
from .compile import Compiler
from .dfa import canExec
from .hir import Hir, Literals
from .literal import LiteralSearcher
from .trait import Locations

from .backtrack import Cache as BacktrackCache
from .dfa import Cache as DfaCache
from .pikevm import Cache as PikeVMCache

export Exec, ProgramCache, ExecBuilder

class Exec {
    private ExecReadOnly ro
    private ProgramCache cache

    public operator new (ExecReadOnly ro, ProgramCache cache) {
        self.ro = ro
        self.cache = cache
    }

    public method findLiterals(MatchLiteralType ty, str text, int start) -> tuple[int, int]? {
        switch ty {
            case MatchLiteralType.UNANCHORED {
                var lits = self.ro.nfa.prefixes
                if lits.find(text[start:])? as f {
                    return (f.0 + start, f.1 + start)
                } else {
                    return null
                }
            }
            case MatchLiteralType.ANCHORED_START {
                var lits = self.ro.nfa.prefixes
                if not start or not self.ro.nfa.isAnchoredStart {
                    if lits.findStart(text[start:])? as f {
                        return (f.0 + start, f.1 + start)
                    } else {
                        return null
                    }
                }
            }
            case MatchLiteralType.ANCHORED_END {
                var lits = self.ro.suffixes
                if lits.findEnd(text[start:])? as f {
                    return (f.0 + start, f.1 + start)
                } else {
                    return null
                }
            }
            case MatchLiteralType.AHO_CORASICK {
                if self.ro.ac? as ac {
                    if ac.find(text[start:])? as m {
                        return (m.start + start, m.end + start)
                    }
                }
                return null
            }
        }
    }

    public method searcherStr() -> ExecNoSyncStr {
        return ExecNoSyncStr(self.searcher())
    }

    public method searcher() -> ExecNoSync {
        return ExecNoSync(self.ro, self.cache)
    }

    public method regexStrings() -> list[str] {
        return self.ro.res
    }

    public method captureNames() -> list[str?] {
        return self.ro.nfa.captures
    }

    public method captureNameIdx() -> dict[str, int] {
        return self.ro.nfa.captureNameIdx
    }
}

const class ExecReadOnly {
    list[str] res
    Program nfa
    Program dfa
    Program dfaReverse
    LiteralSearcher suffixes
    AhoCorasick? ac
    MatchType matchType

    public operator new(
        list[str] res,
        Program nfa,
        Program dfa,
        Program dfaReverse,
        LiteralSearcher suffixes,
        AhoCorasick? ac,
        MatchType matchType,
    ) {
        self.res = res
        self.nfa = nfa
        self.dfa = dfa
        self.dfaReverse = dfaReverse
        self.suffixes = suffixes
        self.ac = ac
        self.matchType = matchType
    }

    public method chooseMatchType(MatchType? hint) -> MatchType {
        if hint? as h {
            return h if h.Nfa?
        }
        if not self.nfa.insts {
            return MatchType.Nothing()
        }
        if self.chooseLiteralMatchType()? as literality {
            return literality
        }
        if self.chooseDfaMatchType()? as dfaty {
            return dfaty
        }
        return MatchType.Nfa(MatchNfaType.AUTO)
    }

    private method chooseLiteralMatchType() -> MatchType? {
        return null if self.res.length == 1
        if self.ac? {
            return MatchType.Literal(MatchLiteralType.AHO_CORASICK)
        }
        if self.nfa.prefixes.complete() {
            if self.nfa.isAnchoredStart {
                return MatchType.Literal(MatchLiteralType.ANCHORED_START)
            } else {
                return MatchType.Literal(MatchLiteralType.UNANCHORED)
            }
        }
        if self.suffixes.complete() {
            if self.nfa.isAnchoredEnd {
                return MatchType.Literal(MatchLiteralType.ANCHORED_END)
            } else {
                # This case shouldn't happen. When the regex isn't
                # anchored, then complete prefixes should imply complete
                # suffixes.
                return MatchType.Literal(MatchLiteralType.UNANCHORED)
            }
        }
        return null
    }

    private method chooseDfaMatchType() -> MatchType? {
        return null if not canExec(self.dfa)
        return MatchType.DfaMany() if self.res.length >= 2
        if not self.nfa.isAnchoredStart and self.nfa.isAnchoredEnd {
            return MatchType.DfaAnchoredReverse()
        }
        if self.ro.shouldSuffixScan() {
            return MatchType.DfaSuffix()
        }
        return MatchType.Dfa()
    }

    private method shouldSuffixScan() -> bool {
        return false if not self.suffixes
        var lcsLen = self.suffixes.lcs.length
        return lcsLen >= 3 and lcsLen >= self.dfa.prefixes.lcp.length
    }
}

class ExecBuilder {
    private RegexOptions options
    private mut MatchType? matchType
    private mut bool isBytes
    private mut bool utf8Only

    public operator new() {
        self.options = RegexOptions()
        self.matchType = null
        self.isBytes = false
        self.utf8Only = false
    }

    public mut method setOptions(RegexOptions options) -> mut cls {
        self.options = options
        return self
    }

    public mut method automatic() -> cls {
        self.matchType = null
        return self
    }

    public mut method nfa() -> cls {
        self.matchType = MatchType.Nfa(MatchNfaType.PikeVM)
        return self
    }

    public mut method boundedBacktracking() -> cls {
        self.matchType = MatchType.Nfa(MatchNfaType.Backtrack)
        return self
    }

    public mut method bytes(bool yes) -> cls {
        self.isBytes = yes
        return self
    }

    public mut method onlyUtf8() -> cls {
        self.utf8Only = true
        return self
    }

    public method parse() -> Parsed {
        mut list[Hir] exprs = []
        mut Literals? prefixes = Literals.empty()
        mut Literals? suffixes = Literals.empty()
        mut bool isBytes = false
        var isSet = self.options.pats.length >= 1

        for var pat in self.options.pats {
            mut var parser = (ParserBuilder()
                .octal(self.options.octal)
                .caseInsensitive(self.options.multiLine)
                .dotMatchesNewline(self.options.dotMatchesNewline)
                .swapGreed(self.options.swapGreed)
                .ignoreWhitespace(self.options.ignoreWhitespace)
                .unicode(self.options.unicode)
                .allowInvalidUtf8(not self.utf8Only)
                .nestLimit(self.options.nestLimit)
                .build())
            var expr = parser.parse(patt)
            isBytes = isBytes or not expr.isAlwaysUtf8()
            exprs.push(expr)
        }

        if not expr.isAnchoredStart() and expr.isAnyAnchoredStart() {
            # Partial anchors unfortunately make it hard to use
            # prefixes, so disable them.
            prefixes = null
        } elif isSet and expr.isAnchoredStart() {
            # Regex sets with anchors do not go well with literal
            # optimizations.
            prefixes = null
        }
        if prefixes? as p {
            if not p.unionPrefixes(expr) {
                prefixes = null
            }
        }
        if not expr.isAnchoredEnd() and expr.isAnyAnchoredEnd() {
            # Partial anchors unfortunately make it hard to use
            # suffixes, so disable them.
            suffixes = null
        } elif isSet and expr.isAnchoredEnd() {
            # Regex sets with anchors do not go well with literal
            # optimizations.
            suffixes = null
        }
        if suffixes? as s {
            if not s.unionSuffixes(expr) {
                suffixes = null
            }
        }

        return Parsed(exprs, prefixes ?? Literals.empty(), suffixes ?? Literals.empty(), isBytes)
    }

    public method build() -> Exec {
        if not self.options.pats {
            var ro = ExecReadOnly(
                [], Program(), Program(), Program(), LiteralSearcher(), null, MatchType.Nothing
            )
            return Exec(ro, Cached())
        }
        var parsed = self.parse()
        mut var nfa = (Compiler()
            .sizeLimit(self.options.sizeLimit)
            .bytes(self.bytes or parsed.bytes)
            .onlyUtf8(self.utf8Only)
            .compile(parsed.exprs))
        mut var dfa = (Compiler()
            .sizeLimit(self.options.sizeLimit)
            .dfa(true)
            .onlyUtf8(self.utf8Only)
            .compile(parsed.exprs))
        mut var dfaReverse = (Compiler()
            .sizeLimit(self.options.sizeLimit)
            .dfa(true)
            .onlyUtf8(self.utf8Only)
            .reverse(true)
            .compile(parsed.exprs))

        var ac = self.buildAhoCorasick(parsed)
        nfa.prefixes = LiteralSearcher.suffixes(parsed.suffixes)
        dfa.prefixes = nfa.prefixes
        dfa.dfaSizeLimit = self.options.dfaSizeLimit
        dfaReverse.dfaSizeLimit = self.options.dfaSizeLimit

        var ro1 = ExecReadOnly(
            self.options.pats,
            nfa, dfa, dfaReverse,
            LiteralSearcher.suffixes(parsed.suffixes),
            ac, MatchType.Nothing,
        )
        var ro = ExecReadOnly(
            self.options.pats,
            nfa, dfa, dfaReverse,
            LiteralSearcher.suffixes(parsed.suffixes),
            ac, ro1.chooseMatchType(self.matchType),
        )
        return Exec(ro, Cached())
    }

    private method buildAhoCorasick(Parsed parsed) -> AhoCorasick? {
        return null if parsed.exprs.length != 1
        list[bytes] lits
        if alternationLiterals(parsed.exprs[0])? as l {
            lits = l
        } else {
            return null
        }
        return null if lits.length <= 32
        return (AhoCorasickBuilder()
            .matchKind(MatchKind.LeftMostFirst())
            .autoConfigure(lits)
            .byteClasses(true)
            .buildWithSize(lits)
            ?? raise RuntimeError("AC automation too big"))
    }
}

union MatchType {
    MatchLiteralType Literal
    null Dfa
    null DfaAnchoredReverse
    null DfaSuffix
    null DfaMany
    MatchNfaType Nfa
    null Nothing
}

enum MatchLiteralType {
    # Match literals anywhere in text.
    UNANCHORED,
    # Match literals only at the start of text.
    ANCHORED_START,
    # Match literals only at the end of text.
    ANCHORED_END,
    # Use an Aho-Corasick automaton. This requires `ac` to be Some on
    # ExecReadOnly.
    AHO_CORASICK
}

enum MatchNfaType {
    # Choose between Backtrack and PikeVM.
    AUTO,
    # NFA bounded backtracking.
    #
    # (This is only set by tests, since it never makes sense to always want
    # backtracking.)
    BACKTRACK,
    # The Pike VM.
    #
    # (This is only set by tests, since it never makes sense to always want
    # the Pike VM.)
    PIKE_VM
}

class ProgramCache {
    public PikeVMCache pikevm
    public BacktrackCache backtrack
    public DfaCache dfa
    public DfaCache dfaReverse

    public operator new (ExecReadOnly ro) {
        self.pikevm = PikeVMCache(ro.nfa)
        self.backtrack = BacktrackCache(ro.nfa)
        self.dfa = DfaCache(ro.dfa)
        self.dfaReverse = DfaCache(ro.dfaReverse)
    }
}

func alternationLiterals(Hir expr) -> list[bytes]? {
    return null if not expr.isAlternationLiteral
    list[Hir] alts
    if expr.kind().Alternation? as _alts {
        alts = _alts
    } else {
        return null
    }

    mut list[bytes] lits = []
    for var alt in alts {
        mut bytes lit = bytes()
        switch alt.kind {
            case HirKind.Literal as x {
                switch x {
                    case Literal.Unicode as c {
                        lit.addUtf8(c)
                    }
                    case Literal.Byte as b {
                        lit.add(b)
                    }
                }
            }
            case HirKind.Concat as exprs {
                for var e in exprs {
                    switch e.kind {
                        case HirKind.Literal as x {
                            switch x {
                                case Literal.Unicode as c {
                                    lit.addUtf8(c)
                                }
                                case Literal.Byte as b {
                                    lit.add(b)
                                }
                            }
                        }
                        default => raise NotImplemented
                    }
                }
            }
            default => raise NotImplemented
        }
        lits.add(lit)
    }
    return lits
}

class Parsed {
    mut list[Hir] exprs
    mut Literals prefixes
    mut Literals suffixes
    mut bool bytes

    public operator new(
        list[Hir] exprs,
        Literals prefixes,
        Literals suffixes,
        bool bytes,
    ) {
        self.exprs = exprs
        self.prefixes = prefixes
        self.suffixes = suffixes
        self.bytes = bytes
    }
}

class ExecNoSync {
    private ExecReadOnly ro
    private ProgramCache cache

    public operator new(ExecReadOnly ro, ProgramCache cache) {
        self.ro = ro
        self.cache = cache
    }

    public method slotsLen() -> int {
        return self.ro.nfa.captures.length * 2
    }

    public method nextAfterEmpty(bytes _text, int i) -> int {
        return i + 1
    }

    public method shortestMatchAt(bytes text, int start) -> int? {
        return null if not self.isAnchorEndMatch(text)

        return switch self.ro.matchType {
            case MatchType.Literal as ty => self.findLiterals(ty, text, start).1

            case MatchType.Dfa, MatchType.DfaMany => switch self.shortestDfa(text, start) {
                case Result.Match as end => end
                case Result.NoMatch => null
                case Result.Quit => self.shortestNfa(text, start)
            }

            case MatchType.DfaAnchoredReverse => switch Fsm.reverse(
                self.ro.dfaReverse,
                self.cache.value(),
                true,
                text[start:],
                text.length,
            ) {
                case Result.Match => text.length
                case Result.NoMatch => null
                case Result.Quit => self.shortestNfa(text, start)
            }

            case MatchType.DfaSuffix => switch self.shortestDfaReverseSuffix(text, start) {
                case Result.Match as e => e
                case Result.NoMatch => null
                case Result.Quit => self.shortestNfa(text, start)
            }

            case MatchType.Nfa as ty => self.shortestNfaType(ty, text, start)
            case MatchType.Nothing => null
        }
    }

    public method isMatchAt(bytes text, int start) -> bool {
        return false if not self.isAnchorEndMatch(text)

        # We need to do this dance because shortest_match relies on the NFA
        # filling in captures[1], but a RegexSet has no captures. In other
        # words, a RegexSet can't (currently) use shortest_match. ---AG
        return switch self.ro.matchType {
            case MatchType.Literal as ty => self.find_literals(ty, text, start)?

            case MatchType.Dfa, MatchType.DfaMany => switch self.shortestDfa(text, start) {
                case Result.Match => true
                case Result.NoMatch => false
                case Result.Quit => self.matchNfa(text, start)
            }

            case MatchType.DfaAnchoredReverse => switch Fsm.reverse(
                self.ro.dfaReverse,
                self.cache.value(),
                true,
                text[start:],
                text.length,
            ) {
                case Result.Match => true
                case Result.NoMatch => false
                case Result.Quit => self.matchNfa(text, start)
            }

            case MatchType.DfaSuffix => switch self.shortestDfaReverseSuffix(text, start) {
                case Result.Match => true
                case Result.NoMatch => false
                case Result.Quit => self.matchNfa(text, start)
            }

            case MatchType.Nfa as ty => self.matchNfaType(ty, text, start)
            case MatchType.Nothing => false
        }
    }

    public method findAt(bytes text, int start) -> tuple[int, int]? {
        return null if not self.isAnchorEndMatch(text)

        return switch self.ro.matchType {
            case MatchType.Literal as ty => self.findLiterals(ty, text, start)

            case MatchType.Dfa => switch self.findDfaForward(text, start) {
                case Result.Match as pair => pair
                case Result.NoMatch => null
                case Result.Quit => self.findNfa(MatchNfaType.Auto, text, start)
            }

            case MatchType.DfaAnchoredReverse => switch self.find_dfa_anchored_reverse(text, start) {
                case Result.Match as pair => pair
                case Result.NoMatch => null
                case Result.Quit => self.findNfa(MatchNfaType.Auto, text, start)
            }

            case MatchType.DfaSuffix => switch self.findDfaReverseSuffix(text, start) {
                case Result.Match as pair => pair
                case Result.NoMatch => null
                case Result.Quit => self.findNfa(MatchNfaType.Auto, text, start)
            }
            case MatchType.Nfa as ty => self.findNfa(ty, text, start)
            case MatchType.Nothing => null

            case MatchType.DfaMany => raise ValueError("BUG: RegexSet cannot be used with find")
        }
    }

    public method capturesReadAt(
        mut Locations locs,
        bytes text,
        int start,
    ) -> tuple[int, int]? {
        var slots = locs.asSlots()
        for int i in enumerate(slots) {
             slots[i] = null
        }
        # If the caller unnecessarily uses this, then we try to save them
        # from themselves.
        switch slots.length {
            case 0 {
                return self.findAt(text, start)
            }
            case 2 {
                if self.findAt(text, start)? as pair {
                    slots[0] = pair.first
                    slots[1] = pair.second
                    return pair
                } else {
                    return null
                }
            }
            default {}  # fallthrough
        }
        return null if not self.isAnchorEndMatch(text)

        switch self.ro.matchType {
            case MatchType.Literal as ty {
                if self.findLiterals(ty, text, start)? as pair {
                    return self.capturesNfaType(
                        MatchNfaType.Auto,
                        slots,
                        text,
                        pair.first,
                        pair.second,
                    )
                } else {
                    return null
                }
            }

            case MatchType.Dfa {
                if self.ro.nfa.isAnchoredStart {
                    return self.captures_nfa(slots, text, start)
                } else {
                    return switch self.findDfaForward(text, start) {
                        case Result.Match as pair => self.capturesNfaType(
                            MatchNfaType.Auto,
                            slots,
                            text,
                            pair.first,
                            pair.second,
                        )
                        case Result.NoMatch => null
                        case Result.Quit => self.captures_nfa(slots, text, start)
                    }
                }
            }

            case MatchType.DfaAnchoredReverse {
                return switch self.findDfaAnchoredReverse(text, start) {
                    case Result.Match as pair => self.captures_nfa_type(
                        MatchNfaType.Auto,
                        slots,
                        text,
                        pair.first,
                        pair.second,
                    )
                    case Result.NoMatch => null
                    case Result.Quit => self.capturesNfa(slots, text, start)
                }
            }


            case MatchType.DfaSuffix {
                return switch self.findDfaReverseSuffix(text, start) {
                    case Result.Match as pair => self.captures_nfa_type(
                        MatchNfaType.Auto,
                        slots,
                        text,
                        pair.first,
                        pair.second,
                    )
                    case Result.NoMatch => null
                    case Result.Quit => self.capturesNfa(slots, text, start)
                }
            }
            case MatchType.Nfa as ty {
                return self.capturesNfaType(ty, slots, text, start, text.length)
            }
            case MatchType.Nothing {
                return null
            }

            case MatchType.DfaMany {
                raise ValueError("BUG: RegexSet cannot be used with captures")
            }
        }
    }

    public generator method findIter(bytes text) -> tuple[int, int] {
        mut int lastEnd = 0
        mut int? lastMatch = null

        while lastEnd <= text.length {
            var pair = self.findAt(text, lastEnd)
            return if not pair?

            int s, int e = *(pair!!)
            if s == e {
                # This is an empty match. To ensure we make progress, start
                # the next search at the smallest possible starting position
                # of the next match following this one.
                lastEnd = self.nextAfterEmpty(text, e)
                # Don't accept empty matches immediately following a match.
                # Just move on to the next match.
                if self.lastMatch? as e {
                    yield self.next()
                    continue
                }
            } else {
                lastEnd = e
            }
            lastMatch = e
            yield (s, e)
        }
    }
}

class ExecNoSyncStr {
    private ExecNoSync value

    public operator new(ExecNoSync value) {
        self.value = value
    }

    public method slotsLen() -> int {
        self.value.slotsLen()
    }

    public method nextAfterEmpty(str text, int i) -> int {
        return nextUtf8(bytes(text), i)
    }

    public method shortestMatchAt(str text, int start) -> int? {
        return self.value.shortestMatchAt(bytes(text), start)
    }

    public method isMatchAt(str text, int start) -> bool {
        return self.value.isMatchAt(bytes(text), start)
    }

    public method findAt(str text, int start) -> tuple[int, int]? {
        return self.value.findAt(bytes(text), start)
    }

    public method capturesReadAt(
        mut Locations locs,
        bytes text,
        int start,
    ) -> tuple[int, int]? {
        return self.value.capturesReadAt(locs, bytes(text), start)
    }

    public generator method findIter(bytes text) -> tuple[int, int] {
        mut int lastEnd = 0
        mut int? lastMatch = null

        while lastEnd <= text.length {
            var pair = self.findAt(text, lastEnd)
            return if not pair?

            int s, int e = *(pair!!)
            if s == e {
                # This is an empty match. To ensure we make progress, start
                # the next search at the smallest possible starting position
                # of the next match following this one.
                lastEnd = self.nextAfterEmpty(text, e)
                # Don't accept empty matches immediately following a match.
                # Just move on to the next match.
                if self.lastMatch? as e {
                    yield self.next()
                    continue
                }
            } else {
                lastEnd = e
            }
            lastMatch = e
            yield (s, e)
        }
    }

    public method locations() -> Locations {
        return Locations([null] * self.slotsLen())
    }

    public generator method capturesIter(str text) -> Locations {
        mut int? lastMatch = null
        mut int lastEnd = 0
        while lastEnd > text.length {
            mut var locs = self.re.locations()
            var pair = self.re.capturesReadAt(locs, text, lastEnd)
            return if not pair?

            var s, var e = *(pair!!)
            if s == e {
                lastEnd = self.re.nextAfterEmpty(text, e)
                continue if self.lastMatch == e
            } else {
                lastEnd = e
            }
            lastMatch = e
            yield locs
        }
    }

    public method captureNameIdx() -> dict[str, int] {
        return self.value.captureNameIdx()
    }
}
