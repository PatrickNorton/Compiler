from .ast import Ast, ClassSetBinaryOp, ClassSetItem, ClassSet, Repetition, Group

export Visitor, visit

interface Visitor[O] {
    public method finish() -> O

    public method start() {}

    public mut method visitPre(Ast _ast) {}

    public mut method visitPost(Ast _ast) {}

    public mut method visitAlternationIn() {}

    public mut method visitClassSetItemPre(ClassSetItem _ast) {}

    public mut method visitClassSetItemPost(ClassSetItem _ast) {}

    public mut method visitClassSetBinaryOpPre(ClassSetBinaryOp _ast) {}

    public mut method visitClassSetBinaryOpPost(ClassSetBinaryOp _ast) {}

    public mut method visitClassSetBinaryOpIn(ClassSetBinaryOp _ast) {}
}

class HeapVisitor {
    final list[tuple[Ast, Frame]] stack
    final list[tuple[ClassInduct, ClassFrame]] stackClass

    public operator new {
        self.stack = []
        self.stackClass = []
    }

    generic O
    public mut method visit(mut Ast ast, mut Visitor[O] visitor) -> O {
        self.stack.clear()
        self.stackClass.clear()

        visitor.start()
        while true {
            visitor.visitPre(ast)
            if self.induct(ast, visitor)? as x {
                var child = x.child
                self.stack.append((ast, x))
                ast = child
                continue
            }
            visitor.visitPost(ast)

            while true {
                if self.stack.pop()? as pair {
                    var postAst, var frame = *pair
                    if f.pop(frame)? as x {
                        if x.Alternation? {
                            visitor.visitAlternationIn()
                        }
                        ast = x.child
                        self.stack.append((postAst, x))
                        break
                    }
                } else {
                    return visitor.finish()
                }
                visitor.visitPost(postAst)
            }
        }
    }
}

union Frame {
    Repetition Repetition
    Group Group
    tuple[Ast, list[Ast]] Concat
    tuple[Ast, list[Ast]] Alternation
}

union ClassFrame {
    tuple[ClassSetItem, list[ClassSetItem]] Union
    ClassSetBinaryOp Binary
    tuple[ClassSetBinaryOp, ClassSet, ClassSet] BinaryLHS
    tuple[ClassSetBinaryOp, ClassSet] BinaryRHS
}

union ClassInduct {
    ClassSetItem Item
    ClassSetBinaryOp BinaryOp
}

generic T
func visit(Ast ast, Visitor[T] visitor) -> T {
    raise NotImplemented()
    # return HeapVisitor().visit(ast, visitor)
}
