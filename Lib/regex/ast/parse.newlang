from .ast import Ast, Alternation, CaptureName, Concat, Comment, Group, Position, Span, WithComments
from .ast import ClassSet, ClassSetUnion, ClassBracketed, ClassSetBinaryOpKind, SetFlags

export AstBuilder, Parser

class AstBuilder {
    mut bool ignoreWhitespace
    mut int nestLimit
    mut bool octal

    public operator new() {
        self.ignoreWhitespace = false
        self.nestLimit = 250
        self.octal = false
    }

    public method build() -> mut Parser {
        list[Comment] comments = []  # FIXME
        list[GroupState] stackGroup = []
        list[ClassState] stackClass = []
        list[CaptureName] captureNames = []
        return Parser (
            Position(0, 1, 1),
            0,
            self.nestLimit,
            self.octal,
            self.ignoreWhitespace,
            self.ignoreWhitespace,
            comments,
            stackGroup,
            stackClass,
            captureNames,
            "",
        )
    }
}

class Parser {
    mut Position pos
    mut int captureIndex
    mut int nestLimit
    mut bool octal
    bool initialIgnoreWhitespace
    mut bool ignoreWhitespace
    final list[Comment] comments
    final list[GroupState] stackGroup
    final list[ClassState] stackClass
    final list[CaptureName] captureNames
    mut str scratch

    public operator new(
        mut Position pos,
        int captureIndex,
        int nestLimit,
        bool octal,
        bool initialIgnoreWhitespace,
        bool ignoreWhitespace,
        mut list[Comment] comments,
        mut list[GroupState] stackGroup,
        mut list[ClassState] stackClass,
        mut list[CaptureName] captureNames,
        str scratch,
    ) {
        self.pos = pos
        self.captureIndex = captureIndex
        self.nestLimit = nestLimit
        self.octal = octal
        self.initialIgnoreWhitespace = initialIgnoreWhitespace
        self.ignoreWhitespace = ignoreWhitespace
        self.comments = comments
        self.stackGroup = stackGroup
        self.stackClass = stackClass
        self.captureNames = captureNames
        self.scratch = scratch
    }

    public method parse(str pattern) -> Ast {
        return ParserI[Parser](self, pattern).parse()
    }
}

class ParserI[P] {
    final P parser
    str pattern

    public operator new(P parser, str pattern) {
        self.parser = parser
        self.pattern = pattern
    }

    mut method parse() -> Ast {
        return self.parseWithComments().ast
    }

    mut method parseWithComments() -> WithComments {
        assert not self.offset() as "parser can only be used once"
        self.parser.reset()
        list[Ast] asts = []  # FIXME
        mut var concat = Concat(self.span(), asts)
        while true {
            self.bumpSpace()
            break if self.isEof()

            switch str(self.chr()) {
                case '(' {concat = self.pushGroup(concat)}
                case ')' {concat = self.popGroup(concat)}
                case '|' {concat = self.pushAlternate(concat)}
                case '[' {
                    var type = self.parseSetClass()
                    concat.asts.push(Ast.Class(type))
                }
                case '?' {
                    concat = self.parseUncountedRepetition(
                        concat,
                        RepetitionKind.ZERO_OR_ONE,
                    )
                }
                case '*' {
                    concat = self.parseUncountedRepetition(
                        concat,
                        RepetitionKind.ZERO_OR_MORE,
                    )
                }
                case '+' {
                    concat = self.parseUncountedRepetition(
                        concat,
                        RepetitionKind.ONE_OR_MORE,
                    )
                }
                case '{' {
                    concat = self.parseCountedRepetition(concat)
                }
                default {
                    concat.asts.push(self.parsePrimitive().intoAst())
                }
            }
        }
        var ast = self.popGroupEnd(concat)
        NestLimiter(self).check(ast)
        var result = WithComments(
            ast,
            self.parser().comments
        )
        self.parser().comments = []
        return result
    }

    private method span() -> Span {
        return Span.splat(self.pos())
    }

    private method chr() -> char {
        return self.charAt(self.offset())
    }

    private method pushGroup(mut Concat concat) -> Concat {
        assert self.chr() == '('[0]
        switch self.parseGroup() {
            case Either.Left as s {
                var ignore = s.flags.flagState(Flag.IGNORE_WHITESPACE)
                if ignore? as v {
                    self.parser().ignoreWhitespace = v
                }
                concat.asts.push(Ast.Flags(s))
                return concat
            }
            case Either.Right as group {
                var oldIgnoreWhitespace = self.ignoreWhitespace()
                var newIgnoreWhitespace = group.flags().flagState(Flag.IGNORE_WHITESPACE)
                self.parser().stackGroup.push(
                    GroupState.Group(GSGroup(concat, group, oldIgnoreWhitespace))
                )
                self.parser().ignoreWhitespace = newIgnoreWhitespace
                return Concat(self.span, [])
            }
        }
    }

    public method parseGroup() -> Either[SetFlags, Group] {
        assert self.chr() == '('[0]
        var openSpan = self.spanChar()
        self.bump()
        self.bumpSpace()
        if self.isLookaroundPrefix() {
            raise self.error(
                Span(openSpan.start, self.span().end),
                ErrorKind.UnsupportedLookAround,
            )
        }
        var innerSpan = self.span()
        if self.bumpIf("?P<") {
            var captureIndex = self.nextCaptureIndex(openSpan)
            var cap = self.parseCaptureName(captureIndex)
            return Either.Right(Group(openSpan, GroupKind.CaptureName(cap), Ast.Empty(self.span)))
        } elif self.bumpIf("?") {
            if self.isEof() {
                raise self.error(openSpan, ErrorKind.GroupUnclosed)
            }
            var flags = self.parseFlags()
            var charEnd = self.chr()
            self.bump()
            if charEnd == ')'[0] {
                if not flags.items {
                    raise self.error(
                        innerSpan,
                        ErrorKind.RepetitionMissing,
                    )
                }
                return Either.Right(SetFlags(Span(self.pos(), openSpan), flags))
            } else {
                assert charEnd == ':'[0]
                return Either.Right(Group(openSpan, GroupKind.NonCapturing(captureIndex), Ast.Empty(self.span())))
            }
        } else {
            var captureIndex = self.nextCaptureIndex(openSpan)
            return Either.Right(Group(openSpan, GroupKind.CaptureIndex(captureIndex), Ast.Empty(self.span())))
        }
    }

}

#|

impl ParserBuilder {

    /// Set the nesting limit for this parser.
    ///
    /// The nesting limit controls how deep the abstract syntax tree is allowed
    /// to be. If the AST exceeds the given limit (e.g., with too many nested
    /// groups), then an error is returned by the parser.
    ///
    /// The purpose of this limit is to act as a heuristic to prevent stack
    /// overflow for consumers that do structural induction on an `Ast` using
    /// explicit recursion. While this crate never does this (instead using
    /// constant stack space and moving the call stack to the heap), other
    /// crates may.
    ///
    /// This limit is not checked until the entire Ast is parsed. Therefore,
    /// if callers want to put a limit on the amount of heap space used, then
    /// they should impose a limit on the length, in bytes, of the concrete
    /// pattern string. In particular, this is viable since this parser
    /// implementation will limit itself to heap space proportional to the
    /// lenth of the pattern string.
    ///
    /// Note that a nest limit of `0` will return a nest limit error for most
    /// patterns but not all. For example, a nest limit of `0` permits `a` but
    /// not `ab`, since `ab` requires a concatenation, which results in a nest
    /// depth of `1`. In general, a nest limit is not something that manifests
    /// in an obvious way in the concrete syntax, therefore, it should not be
    /// used in a granular way.
    pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {
        self.nest_limit = limit;
        self
    }

    /// Whether to support octal syntax or not.
    ///
    /// Octal syntax is a little-known way of uttering Unicode codepoints in
    /// a regular expression. For example, `a`, `\x61`, `\u0061` and
    /// `\141` are all equivalent regular expressions, where the last example
    /// shows octal syntax.
    ///
    /// While supporting octal syntax isn't in and of itself a problem, it does
    /// make good error messages harder. That is, in PCRE based regex engines,
    /// syntax like `\0` invokes a backreference, which is explicitly
    /// unsupported in Rust's regex engine. However, many users expect it to
    /// be supported. Therefore, when octal support is disabled, the error
    /// message will explicitly mention that backreferences aren't supported.
    ///
    /// Octal syntax is disabled by default.
    pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {
        self.octal = yes;
        self
    }

    /// Enable verbose mode in the regular expression.
    ///
    /// When enabled, verbose mode permits insigificant whitespace in many
    /// places in the regular expression, as well as comments. Comments are
    /// started using `#` and continue until the end of the line.
    ///
    /// By default, this is disabled. It may be selectively enabled in the
    /// regular expression by using the `x` flag regardless of this setting.
    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {
        self.ignore_whitespace = yes;
        self
    }'
}
|#

class GSGroup {
    Concat concat
    Group group
    bool ignoreWhitespace
}

union GroupState {
    GSGroup Group
    Alternation Alternation
}

union ClassState {
    tuple[ClassSetUnion, ClassBracketed] Open
    tuple[ClassSetBinaryOpKind, ClassSet] Op
}

union Either[T, U] {
    T Left
    U Right
}
