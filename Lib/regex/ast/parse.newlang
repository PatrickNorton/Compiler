from string import StringBuilder

from .ast import Ast, Alternation, CaptureName, Concat, Comment, Group, Position, Span, WithComments, GroupKind
from .ast import ClassSet, ClassSetUnion, ClassBracketed, ClassSetBinaryOpKind, SetFlags, ErrorKind, AstError
from .ast import Flags, Flag, Class, ClassSetItem, ClassAscii, ClassSetBinaryOp, ClassAsciiKind, Literal, LiteralKind
from .ast import RepetitionKind, RepetitionOp, Repetition, RepetitionRange, Assertion, ClassPerl, ClassUnicode

export AstBuilder, Parser

# FIXME: Import these from 'string'
str ASCII_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz'
str ASCII_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
str ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE
str DIGITS = '0123456789'
str WHITESPACE = ' \t\r\n\f\v'

class AstBuilder {
    mut bool ignoreWhitespace
    mut int nestLimit
    mut bool octal

    public operator new() {
        self.ignoreWhitespace = false
        self.nestLimit = 250
        self.octal = false
    }

    public method build() -> mut Parser {
        list[Comment] comments = []  # FIXME
        list[GroupState] stackGroup = []
        list[ClassState] stackClass = []
        list[CaptureName] captureNames = []
        return Parser (
            Position(0, 1, 1),
            0,
            self.nestLimit,
            self.octal,
            self.ignoreWhitespace,
            self.ignoreWhitespace,
            comments,
            stackGroup,
            stackClass,
            captureNames,
            "",
        )
    }
}

class Parser {
    mut Position pos
    mut int captureIndex
    mut int nestLimit
    mut bool octal
    bool initialIgnoreWhitespace
    mut bool ignoreWhitespace
    final list[Comment] comments
    final list[GroupState] stackGroup
    final list[ClassState] stackClass
    final list[CaptureName] captureNames
    mut str scratch

    public operator new(
        mut Position pos,
        int captureIndex,
        int nestLimit,
        bool octal,
        bool initialIgnoreWhitespace,
        bool ignoreWhitespace,
        mut list[Comment] comments,
        mut list[GroupState] stackGroup,
        mut list[ClassState] stackClass,
        mut list[CaptureName] captureNames,
        str scratch,
    ) {
        self.pos = pos
        self.captureIndex = captureIndex
        self.nestLimit = nestLimit
        self.octal = octal
        self.initialIgnoreWhitespace = initialIgnoreWhitespace
        self.ignoreWhitespace = ignoreWhitespace
        self.comments = comments
        self.stackGroup = stackGroup
        self.stackClass = stackClass
        self.captureNames = captureNames
        self.scratch = scratch
    }

    public method parse(str pattern) -> Ast {
        return ParserI(self, pattern).parse()
    }
}

class ParserI {
    final Parser parser
    str pattern

    public operator new(mut Parser parser, str pattern) {
        self.parser = parser
        self.pattern = pattern
    }

    mut method parse() -> Ast {
        return self.parseWithComments().ast
    }

    mut method parseWithComments() -> WithComments {
        assert not self.offset() as "parser can only be used once"
        self.parser.reset()
        list[Ast] asts = []  # FIXME
        mut var concat = Concat(self.span(), asts)
        while true {
            self.bumpSpace()
            break if self.isEof()

            switch str(self.chr()) {
                case '(' {concat = self.pushGroup(concat)}
                case ')' {concat = self.popGroup(concat)}
                case '|' {concat = self.pushAlternate(concat)}
                case '[' {
                    var type = self.parseSetClass()
                    concat.asts.push(Ast.Class(type))
                }
                case '?' {
                    concat = self.parseUncountedRepetition(
                        concat,
                        RepetitionKind.ZeroOrOne(),
                    )
                }
                case '*' {
                    concat = self.parseUncountedRepetition(
                        concat,
                        RepetitionKind.ZeroOrMore(),
                    )
                }
                case '+' {
                    concat = self.parseUncountedRepetition(
                        concat,
                        RepetitionKind.OneOrMore(),
                    )
                }
                case '{' {
                    concat = self.parseCountedRepetition(concat)
                }
                default {
                    concat.asts.push(self.parsePrimitive().intoAst())
                }
            }
        }
        var ast = self.popGroupEnd(concat)
        NestLimiter(self).check(ast)
        var result = WithComments(
            ast,
            self.parser().comments
        )
        self.parser().comments = []
        return result
    }

    private method parseUncountedRepetition(
        Concat concat,
        RepetitionKind kind,
    ) -> Concat {
        assert self.chr() in "?*+"
        var opStart = self.parser.pos
        raise self.error(self.span(), ErrorKind.RepetitionMissing()) if concat.asts
        Ast ast = concat.asts[-1]
        if ast.Empty? or ast.Flags? {
            raise self.error(self.span(), ErrorKind.RepetitionMissing())
        }
        mut var greedy = true
        if self.bump() and self.chr() == '?'[0] {
            greedy = false
            self.bump()
        }
        var span = ast.span.withEnd(self.parser.pos)
        var op = RepetitionOp(Span(opStart, self.parser.pos), kind)
        var newAsts = concat.asts[:-1] + [Ast.Repetition(Repetition(span, op, greedy, ast))]
        return Concat(concat.span, newAsts)
    }

    private method parseCountedRepetition(Concat concat) -> Concat {
        assert self.chr() == '{'[0]
        var start = self.parser.pos
        if not concat.asts {
            raise self.error(self.span(), ErrorKind.RepetitionMissing())
        }
        var ast = concat.asts[-1]
        if ast.Empty? or ast.Flags? {
            raise self.error(self.span(), ErrorKind.RepetitionMissing())
        }
        if not self.bumpAndBumpSpace() {
            raise self.error(Span(start, self.parser.pos), ErrorKind.RepetitionCountUnclosed())
        }
        var countStart = self.parseDecimal()
        mut var repRange = RepetitionRange.Exactly(countStart)
        if self.isEof() {
            raise self.error(Span(start, self.parser.pos), ErrorKind.RepetitionCountUnclosed())
        }
        if self.chr() == ','[0] {
            if not self.bumpAndBumpSpace() {
                raise self.error(Span(start, self.parser.pos), ErrorKind.RepetitionCountUnclosed())
            }
            if self.chr() != '}'[0] {
                var countEnd = self.parseDecimal()
                repRange = RepetitionRange.Bounded((countStart, countEnd))
            } else {
                repRange = RepetitionRange.AtLeast(countStart)
            }
        }
        if self.isEof() or self.chr() != '}'[0] {
            raise self.error(Span(start, self.parser.pos), ErrorKind.RepetitionCountUnclosed())
        }

        mut var greedy = true
        if self.bumpAndBumpSpace() and self.chr() == '?'[0] {
            greedy = false
            self.bump()
        }

        var opSpan = Span(start, self.parser.pos)
        if not repRange.isValid() {
            raise self.error(opSpan, ErrorKind.RepetitionCountInvalid())
        }
        var repOp = RepetitionOp(opSpan, RepetitionKind.Range(repRange))
        var rep = Repetition(ast.span.withEnd(self.parser.pos), repOp, greedy, ast)
        var newAsts = concat.asts[:-1] + [Ast.Repetition(rep)]
        return Concat(concat.span, newAsts)
    }

    private method parseDecimal() -> int {
        mut var scratch = StringBuilder("")

        while not self.isEof() and self.chr() in WHITESPACE {
            self.bump()
        }
        var start = self.parser.pos
        while not self.isEof() and self.chr() in DIGITS {
            scratch.push(self.chr())
            self.bumpAndBumpSpace()
        }
        var span = Span(start, self.parser.pos)
        while not self.isEof() and self.chr() in WHITESPACE {
            self.bumpAndBumpSpace()
        }
        var digits = str(scratch)
        if not digits {
            raise self.error(span, ErrorKind.DecimalEmpty())
        }
        return int(digits)
    }

    private method parsePrimitive() -> Primitive {
        switch str(self.chr()) {
            case '\\' {
                return self.parseEscape()
            }
            case '.' {
                var ast = Primitive.Dot(self.spanChar())
                self.bump()
                return ast
            }
            case '^' {
                var ast = Primitive.Assertion(Assertion(self.spanChar(), AssertionKind.StartLine()))
                self.bump()
                return ast
            }
            case '$' {
                var ast = Primitive.Assertion(Assertion(self.spanChar(), AssertionKind.EndLine()))
                self.bump()
                return ast
            }
            default {
                var ast = Primitive.Literal(Literal(self.spanChar(), LiteralKind.Verbatim(), self.chr()))
                self.bump()
                return ast
            }
        }
    }

    private method parseEscape() -> Primitive {
        assert self.chr() == '\\'[0]
        var start = self.parser.pos
        if not self.bump() {
            raise self.error(Span(start, self.parser.pos), ErrorKind.EscapeUnexpectedEof())
        }
        var c = self.chr()
        if c in "01234567" {
            if not self.parser.octal {
                raise self.error(Span(start, self.spanChar().end), ErrorKind.UnsupportedBackReference())
            }
        } elif c in "89" {
            raise self.error(Span(start, self.spanChar().end), ErrorKind.UnsupportedBackReference())
        } elif c in "xuU" {
            mut var lit = self.parseHex()
            lit.span.start = start
            return Primitive.Literal(lit)
        } elif c in "pP" {
            mut var c = self.parseUnicodeClass()
            c.span.start = start
            return Primitive.Unicode(c)
        } elif c in "dswDSW" {
            mut var c = self.parsePerlClass()
            c.span.start = start
            return Primitive.Perl(c)
        }

        self.bump()
        var span = Span(start, self.parser.pos)
        if isMetaCharacter(c) {
            return Primitive.Literal(Literal(span, LiteralKind.Punctuation, c))
        }
        var special = lambda SpecialLiteralKind kind, char c => Primitive.Literal(
            Literal(span, LiteralKind.Special(kind), c)
        )
        switch str(c) {
            case 'a' => special(SpecialLiteralKind.Bell(), '\x07'[0])
            case 'f' => special(SpecialLiteralKind.FormFeed(), '\x0C'[0])
            case 't' => special(SpecialLiteralKind.Tab(), '\t'[0])
            case 'n' => special(SpecialLiteralKind.LineFeed(), '\n'[0])
            case 'r' => special(SpecialLiteralKind.CarriageReturn(), '\r'[0])
            case 'v' => special(SpecialLiteralKind.VerticalTab(), '\x0B'[0])
            case ' ' => (special(SpecialLiteralKind.Space(), ' ')
                if self.ignore_whitespace() else raise self.error(span, ErrorKind.EscapeUnrecognized()))
            case 'A' => Primitive.Assertion(Assertion(span, AssertionKind.StartText()))
            case 'z' => Primitive.Assertion(Assertion(span, AssertionKind.EndText()))
            case 'b' => Primitive.Assertion(Assertion(span, AssertionKind.WordBoundary()))
            case 'B' => Primitive.Assertion(Assertion(span, AssertionKind.NotWordBoundary()))
            default  => raise self.error(span, ErrorKind.EscapeUnrecognized())
        }
    }

    private method parseHex() -> Literal {
        assert self.chr() in "xuU"

        var hexKind = switch self.chr() {
            case 'x' => HexLiteralKind.X
            case 'u' => ast.HexLiteralKind.UNICODE_SHORT
            default => ast.HexLiteralKind.UNICODE_LONG
        }
        if not self.bumpAndBumpSpace() {
            raise self.error(self.span(), ErrorKind.EscapeUnexpectedEof())
        }
        if self.char() == '{' {
            self.parseHexBrace(hexKind)
        } else {
            self.parseHexDigits(hexKind)
        }
    }

    private method parseHexDigits(HexLiteralKind kind) -> Literal {
        final var scratch = StringBuilder()

        var start = self.parser.pos
        for i in [0:kind.digits()] {
            if i > 0 and not self.bumpAndBumpSpace() {
                raise self.error(self.span(), ErrorKind.EscapeUnexpectedEof())
            }
            if not self.chr() in HEX_DIGITS {
                raise self.error(self.spanChar(), ErrorKind.EscapeHexInvalidDigit)
            }
            scratch.add(self.chr())
        }
        self.bumpAndBumpSpace()
        var end = self.parser.pos
        var hex = str(scratch)
        return Literal(Span(start, end), LiteralKind.HexFixed(kind), int(hex))
    }

    private method parseHexBrace(HexLiteralKind kind) -> Literal {
        final var scratch = StringBuilder()

        var bracePos = self.position.pos
        var start = self.spanChar().end
        while self.bumpAndBumpSpace() and self.chr() != '}'[0] {
            if not isHex(self.chr()) {
                raise self.error(self.span_chr(), ErrorKind.EscapeHexInvalidDigit())
            }
            scratch.push(self.chr())
        }
        if self.isEof() {
            raise self.error(self.span(), ErrorKind.EscapeUnexpectedEof())
        }
        var end = self.parser.pos
        var hex = str(scratch)
        assert self.chr() == '}'[0]
        self.bumpAndBumpSpace()

        if not hex {
            raise self.error(Span(bracePos, self.parser.pos), ErrorKind.EscapeHexEmpty())
        }
        var chr = char(int(hex, 16))
        return Literal(Span(start, self.parser.pos), LiteralKind.HexBrace(kind))
    }

    private method peek() -> char? {
        return null if self.isEof()
        return self.pattern[self.offset() + 1]
    }


    private method span() -> Span {
        return Span.splat(self.pos())
    }

    private method chr() -> char {
        return self.pattern[self.offset()]
    }

    private method offset() -> int {
        return self.parser.pos.offset
    }

    private method line() -> int {
        return self.parser.pos.line
    }

    private method column() -> int {
        return self.parser.pos.column
    }

    private method spanChar() -> Span {
        mut var next = Position(self.offset() + 1, self.line(), self.column() + 1)
        if self.chr() == '\n' {
            next = Position(next.offset, next.line + 1, next.column + 1)
        }
        return Span(self.parser.pos, next)
    }

    private mut method nextCaptureIndex(Span span) -> int {
        var current = self.parser.captureIndex
        var i = current + 1
        self.parser.captureIndex = i
        return i
    }

    private mut method pushGroup(mut Concat concat) -> Concat {
        assert self.chr() == '('[0]
        switch self.parseGroup() {
            case Either.Left as s {
                var ignore = s.flags.flagState(Flag.IGNORE_WHITESPACE)
                if ignore? as v {
                    self.parser.ignoreWhitespace = v
                }
                concat.asts.push(Ast.Flags(s))
                return concat
            }
            case Either.Right as group {
                var oldIgnoreWhitespace = self.parser.ignoreWhitespace
                var newIgnoreWhitespace = group.flags.flatMap(
                    lambda Flags x -> bool? => x.flagState(Flag.IGNORE_WHITESPACE)
                ) ?? oldIgnoreWhitespace
                self.parser.stackGroup.push(
                    GroupState.Group(GSGroup(concat, group, oldIgnoreWhitespace))
                )
                self.parser.ignoreWhitespace = newIgnoreWhitespace
                list[Ast] asts = []  # FIXME
                return Concat(self.span(), asts)
            }
        }
    }

    private mut method popGroup(Concat groupConcat_) -> Concat {
        mut var groupConcat = groupConcat_
        assert self.chr() == ')'[0]
        final var stack = self.parser.stackGroup
        mut Concat concat
        mut Group group
        mut bool ignoreWhitespace
        mut Alternation? alt
        if stack.pop()? as gs {
            switch gs {
                case GroupState.Group as g {
                    concat = g.concat
                    group = g.group
                    ignoreWhitespace = g.ignoreWhitespace
                    alt = null
                }
                case GroupState.Alternation as a {
                    if stack.pop()? as g {
                        switch g {
                            case GroupState.Group as g {
                                concat = g.concat
                                group = g.group
                                ignoreWhitespace = g.ignoreWhitespace
                                alt = a
                            }
                            default {
                                raise self.error(self.spanChar(), ErrorKind.GroupUnopened())
                            }
                        }
                    } else {
                        raise self.error(self.spanChar(), ErrorKind.GroupUnopened())
                    }
                }
            }
        }
        self.parser.ignoreWhitespace = ignoreWhitespace
        groupConcat = Concat(Span(groupConcat.span.start, self.parser.pos), groupConcat.asts)
        self.bump()
        group = group.withSpan(Span(group.span.start, self.parser.pos))
        if alt? as a {
            var span = Span(a.span.start, groupConcat.span.end)
            var asts = a.asts + [groupConcat.intoAst()]
            group = group.withAst(Alternation(span, asts).intoAst())
        } else {
            group = group.withAst(groupConcat.intoAst())
        }
        concat.asts.add(Ast.Group(group))
        return concat
    }

    private method parseCaptureName(int captureIndex) -> CaptureName {
        if self.isEof() {
            raise self.error(self.span(), ErrorKind.GroupNameUnexpectedEof())
        }
        var start = self.parser.pos
        while true {
            break if self.chr() == '>'[0]
            if not isCaptureChar(self.chr(), self.parser.pos == start) {
                raise self.error(
                    self.spanChar(),
                    ErrorKind.GroupNameInvalid(),
                )
            }
            break if not self.bump()
        }
        var end = self.parser.pos
        if self.isEof() {
            raise self.error(self.span(), ErrorKind.GroupNameUnexpectedEof())
        }
        assert self.chr() == '>'[0]
        self.bump()
        var name = self.pattern[start.offset:end.offset]
        if not name {
            raise self.error(Span(start, start), ErrorKind.GroupNameEmpty())
        }
        var capname = CaptureName(Span(start, end), name, captureIndex)
        self.addCaptureName(capname)
        return capname
    }

    public mut method parseGroup() -> Either[SetFlags, Group] {
        assert self.chr() == '('[0]
        var openSpan = self.spanChar()
        self.bump()
        self.bumpSpace()
        if self.isLookaroundPrefix() {
            raise self.error(
                Span(openSpan.start, self.span().end),
                ErrorKind.UnsupportedLookAround(),
            )
        }
        var innerSpan = self.span()
        if self.bumpIf("?P<") {
            var captureIndex = self.nextCaptureIndex(openSpan)
            var cap = self.parseCaptureName(captureIndex)
            return Either[SetFlags, Group].Right(Group(openSpan, GroupKind.CaptureName(cap), Ast.Empty(self.span())))
        } elif self.bumpIf("?") {
            if self.isEof() {
                raise self.error(openSpan, ErrorKind.GroupUnclosed())
            }
            var flags = self.parseFlags()
            var charEnd = self.chr()
            self.bump()
            if charEnd == ')'[0] {
                if not flags.items {
                    raise self.error(
                        innerSpan,
                        ErrorKind.RepetitionMissing(),
                    )
                }
                return Either[SetFlags, Group].Left(SetFlags(Span(self.parser.pos, openSpan.end), flags))
            } else {
                assert charEnd == ':'[0]
                var group = Group(openSpan, GroupKind.NonCapturing(flags), Ast.Empty(self.span()))
                return Either[SetFlags, Group].Right(group)
            }
        } else {
            var captureIndex = self.nextCaptureIndex(openSpan)
            var group = Group(openSpan, GroupKind.CaptureIndex(captureIndex), Ast.Empty(self.span()))
            return Either[SetFlags, Group].Right(group)
        }
    }

    private method parseFlags() -> Flags {
        mut var flags = Flags(self.span(), [])
        mut Span? lastWasNegation = null
        while self.chr() != ':'[0] and self.chr() != ')'[0] {
            if self.chr() == '-'[0] {
                lastWasNegation = self.spanChar()
                var item = FlagsItem(self.spanChar(), FlagsItemKind.Negation())
                if flags.addItem(item)? as i {
                    raise self.error(self.spanChar(), ErrorKind.FlagRepeatedNegation(flags.items[i].span))
                }
            } else {
                lastWasNegation = null
                var item = FlagsItem(self.spanChar(), FlagsItemKind.Flag(self.parseFlag()))
                if flags.addItem(item)? as i {
                    raise self.error(self.spanChar(), ErrorKind.FlagDuplicate(flags.items[i].span))
                }
            }
            if not self.bump() {
                raise self.error(self.span(), ErrorKind.FlagUnexpectedEof())
            }
        }
        if lastWasNegation? as span {
            raise self.error(span, ErrorKind.FlagDanglingNegation())
        }
        flags.span.end = self.pos()
        return flags
    }

    public method pushAlternate(Concat concat) -> Concat {
        assert self.chr() == '|'[0]
        var conc = concat.withSpan(Span(concat.span.start, self.parser.pos))
        self.pushOrAddAlternation(concat)
        self.bump()
        list[Ast] asts = []  # FIXME
        return Concat(self.span(), asts)
    }

    public mut method pushOrAddAlternation(Concat concat) {
        mut var stack = self.parser.stackGroup
        if stack {
            stack[-1].add(concat.intoAst())
        } else {
            var span = Span(concat.span.start, self.parser.pos)
            stack.push(GroupState.Alternation(Alternation(span, [concat.intoAst()])))
        }
    }

    private mut method parseSetClass() -> Class {
        assert self.chr() == '['[0]
        list[ClassSetItem] items = []
        mut var classUnion = ClassSetUnion(self.span(), items)
        while true {
            self.bumpSpace()
            if self.isEof() {
                raise self.unclosedClassError()
            }
            switch str(self.chr()) {
                case '[' {
                    if self.parser.stackClass {
                        if self.maybeParseAsciiClass()? as c {
                            classUnion.add(ClassSetItem.Ascii(c))
                        }
                    }
                    classUnion = self.pushClassOpen(classUnion)
                }
                case ']' {
                    switch self.popClass(classUnion) {
                        case Either.Left as nestedUnion {
                            classUnion = nestedUnion
                        }
                        case Either.Right as type {
                            return type
                        }
                    }
                }
                case '&' {
                    if self.peek() == '&'[0] {
                        classUnion = self.pushClassOp(ClassSetBinaryOpKind.INTERSECTION, classUnion)
                    } else {
                        classUnion.push(self.parseSetClassRange())
                    }
                }
                case '-' {
                    if self.peek() == '-'[0] {
                        classUnion = self.pushClassOp(ClassSetBinaryOpKind.DIFFERENCE, classUnion)
                    } else {
                        classUnion.push(self.parseSetClassRange())
                    }
                }
                case '~' {
                    if self.peek() == '~'[0] {
                        classUnion = self.pushClassOp(ClassSetBinaryOpKind.SYMMETRIC_DIFFERENCE, classUnion)
                    } else {
                        classUnion.push(self.parseSetClassRange())
                    }
                }
                default {
                    classUnion.push(self.parseSetClassRange())
                }
            }
        }
    }

    private method pushClassOpen(ClassSetUnion parentUnion) -> ClassSetUnion {
        assert self.chr() == '['[0]

        var nestedSet, var nestedUnion = self.parseSetClassOpen()
        self.parser.stackClass.add(ClassState.Open(parentUnion, nestedSet))
        return nestedUnion
    }

    private method parseSetClassOpen() -> ClassBracketed, ClassSetUnion {
        assert self.chr() == '['[0]
        var start = self.parser.pos
        if not self.bumpAndBumpSpace() {
            raise self.error(Span(start, self.parser.pos), ErrorKind.ClassUnclosed())
        }

        bool negated
        if self.chr() != '^'[0] {
            negated = false
        } else {
            if not self.bumpAndBumpSpace() {
                raise self.error(Span(start, self.parser.pos), ErrorKind.ClassUnclosed())
            }
            negated = true
        }

        list[ClassSetItem] items = []  # FIXME
        mut var unionSet = ClassSetUnion(self.span(), items)
        while self.chr() == '-'[0] {
            unionSet.add(ClassSetItem.Literal(Literal(self.spanChar(), LiteralKind.Verbatim(), '-'[0])))
            if not self.bumpAndBumpSpace() {
                raise self.error(Span(start, self.parser.pos), ErrorKind.ClassUnclosed())
            }
        }
        if not unionSet.items and self.chr() == ']'[0] {
            unionSet.add(ClassSetItem.Literal(Literal(self.spanChar(), LiteralKind.Verbatim(), ']'[0])))
            if not self.bumpAndBumpSpace() {
                raise self.error(Span(start, self.parser.pos), ErrorKind.ClassUnclosed())
            }
        }
        list[ClassSetItem] items_ = []  # FIXME
        var kind = ClassSet.unionSet(ClassSetUnion(Span(unionSet.span.start, unionSet.span.start), items_))
        var s = ClassBracketed(Span(start, self.parser.pos), negated, kind)
        return s, unionSet
    }


    private method popClass(ClassSetUnion nestedUnion) -> Either[ClassSetUnion, Class] {
        assert self.chr() == ']'[0]

        var item = ClassSet.Item(nestedUnion.intoItem())
        var prevset = self.popClassOp(item)
        mut var stack = self.parser.stackClass
        switch stack.pop()!! {
            case ClassState.Op {
                raise NotImplemented()  # unexpected ClassState::Op
            }
            case ClassState.Open as pair {
                mut var un, var s = *pair
                self.bump()
                s.span = Span(s.span.start, self.parser.pos)
                s.kind = prevset
                if not stack {
                    return Either[ClassSetUnion, Class].Right(Class.Bracketed(s))
                } else {
                    un.add(ClassSetItem.Bracketed(s))
                    return Either[ClassSetUnion, Class].Left(un)
                }
            }
        }
    }

    private mut method maybeParseAsciiClass() -> ClassAscii? {
        assert self.chr() == '['[0]
        var start = self.parser.pos
        mut var negated = false
        if not self.bump() or self.chr() != ':'[0] {
            self.parser.pos = start
            return null
        }
        if not self.bump() {
            self.parser.pos = start
            return null
        }
        if self.chr() == '^'[0] {
            negated = true
            if not self.bump() {
                self.parser.pos = start
                return null
            }
        }
        var nameStart = self.offset()
        while self.chr() != ':'[0] and self.bump() {}
        if self.isEof() {
            self.parser.pos = start
            return null
        }
        var name = self.pattern[nameStart:self.offset()]
        if not self.bumpIf(":]") {
            self.parser.pos = start
            return null
        }
        if ClassAsciiKind.fromName(name)? as kind {
            return ClassAscii(Span(start, self.parser.pos), kind, negated)
        } else {
            self.parser.pos = start
            return null
        }
    }

    private mut method pushClassOp(
        ClassSetBinaryOpKind nextKind,
        ClassSetUnion nextUnion,
    ) -> ClassSetUnion {
        var item = ClassSet.Item(nextUnion.intoItem())
        var newLhs = self.popClassOp(item)
        self.parser.stackClass.add(ClassState.Op(nextKind, newLhs))
        list[ClassSetItem] items = []
        return ClassSetUnion(self.span(), items)
    }

    private mut method popClassOp(ClassSet rhs) -> ClassSet {
        mut var stack = self.parser.stackClass
        switch stack.pop()!! {
            case ClassState.Op as pair {
                var kind, var lhs = *pair
                var span = Span(lhs.span.start, rhs.span.end)
                return ClassSet.BinaryOp(ClassSetBinaryOp(span, kind, lhs, rhs))
            }
            case ClassState.Open as state {
                stack.add(state)
                return rhs
            }
        }
    }

    private method error(Span span, ErrorKind kind) -> AstError {
        return AstError(span, self.pattern, kind)
    }

    private method unclosedClassError() -> AstError {
        for var state in reversed(self.parser().stackClass) {
            if state.Open? as p {
                return self.error(p.0.span, ErrorKind.ClassUnclosed())
            }
        }
        raise NotImplemented()
    }
}

#|

impl ParserBuilder {

    /// Set the nesting limit for this parser.
    ///
    /// The nesting limit controls how deep the abstract syntax tree is allowed
    /// to be. If the AST exceeds the given limit (e.g., with too many nested
    /// groups), then an error is returned by the parser.
    ///
    /// The purpose of this limit is to act as a heuristic to prevent stack
    /// overflow for consumers that do structural induction on an `Ast` using
    /// explicit recursion. While this crate never does this (instead using
    /// constant stack space and moving the call stack to the heap), other
    /// crates may.
    ///
    /// This limit is not checked until the entire Ast is parsed. Therefore,
    /// if callers want to put a limit on the amount of heap space used, then
    /// they should impose a limit on the length, in bytes, of the concrete
    /// pattern string. In particular, this is viable since this parser
    /// implementation will limit itself to heap space proportional to the
    /// lenth of the pattern string.
    ///
    /// Note that a nest limit of `0` will return a nest limit error for most
    /// patterns but not all. For example, a nest limit of `0` permits `a` but
    /// not `ab`, since `ab` requires a concatenation, which results in a nest
    /// depth of `1`. In general, a nest limit is not something that manifests
    /// in an obvious way in the concrete syntax, therefore, it should not be
    /// used in a granular way.
    pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {
        self.nest_limit = limit;
        self
    }

    /// Whether to support octal syntax or not.
    ///
    /// Octal syntax is a little-known way of uttering Unicode codepoints in
    /// a regular expression. For example, `a`, `\x61`, `\u0061` and
    /// `\141` are all equivalent regular expressions, where the last example
    /// shows octal syntax.
    ///
    /// While supporting octal syntax isn't in and of itself a problem, it does
    /// make good error messages harder. That is, in PCRE based regex engines,
    /// syntax like `\0` invokes a backreference, which is explicitly
    /// unsupported in Rust's regex engine. However, many users expect it to
    /// be supported. Therefore, when octal support is disabled, the error
    /// message will explicitly mention that backreferences aren't supported.
    ///
    /// Octal syntax is disabled by default.
    pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {
        self.octal = yes;
        self
    }

    /// Enable verbose mode in the regular expression.
    ///
    /// When enabled, verbose mode permits insigificant whitespace in many
    /// places in the regular expression, as well as comments. Comments are
    /// started using `#` and continue until the end of the line.
    ///
    /// By default, this is disabled. It may be selectively enabled in the
    /// regular expression by using the `x` flag regardless of this setting.
    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {
        self.ignore_whitespace = yes;
        self
    }'
}
|#

class GSGroup {
    Concat concat
    Group group
    bool ignoreWhitespace

    public operator new(Concat concat, Group group, bool ignoreWhitespace) {
        self.concat = concat
        self.group = group
        self.ignoreWhitespace = ignoreWhitespace
    }
}

union GroupState {
    GSGroup Group
    Alternation Alternation
}

union ClassState {
    tuple[ClassSetUnion, ClassBracketed] Open
    tuple[ClassSetBinaryOpKind, ClassSet] Op
}

union Either[T, U] {
    T Left
    U Right
}

union Primitive {
    Literal Literal
    Assertion Assertion
    Span Dot
    ClassPerl Perl
    ClassUnicode Unicode
}

func isCaptureChar(char c, bool first) -> bool {
    return (c == '_'[0]
        or (not first and c in DIGITS or c in ".[]")
        or c in ASCII_LETTERS)
}
